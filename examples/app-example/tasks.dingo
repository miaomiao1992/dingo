package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
)

// Task represents a single TODO item
type Task struct {
	ID          int    `json:"id"`
	Description string `json:"description"`
	Completed   bool   `json:"completed"`
}

// TaskStore holds all tasks
type TaskStore struct {
	Tasks  []Task `json:"tasks"`
	NextID int    `json:"next_id"`
}

// getStorePath returns the path to the tasks file
// Demonstrates parameter type annotations
func getStorePath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return ".todo-cli.json"
	}
	return filepath.Join(home, ".todo-cli.json")
}

// loadTasks loads tasks from disk
// Demonstrates error propagation pattern
func loadTasks() (TaskStore, error) {
	let path = getStorePath()

	// Check if file exists
	if _, err := os.Stat(path); os.IsNotExist(err) {
		// Return empty store if file doesn't exist
		return TaskStore{
			Tasks:  []Task{},
			NextID: 1,
		}, nil
	}

	// Read file
	data, err := os.ReadFile(path)
	if err != nil {
		return TaskStore{}, err
	}

	// Parse JSON
	var store TaskStore
	if err := json.Unmarshal(data, &store); err != nil {
		return TaskStore{}, err
	}

	return store, nil
}

// saveTasks saves tasks to disk
// Demonstrates error handling
func saveTasks(store: TaskStore) error {
	let path = getStorePath()

	// Marshal to JSON
	data, err := json.MarshalIndent(store, "", "  ")
	if err != nil {
		return err
	}

	// Write to file
	return os.WriteFile(path, data, 0644)
}

// addTask adds a new task
func addTask(store: *TaskStore, description: string) {
	let task = Task{
		ID:          store.NextID,
		Description: description,
		Completed:   false,
	}
	store.Tasks = append(store.Tasks, task)
	store.NextID++
}

// listTasks displays all tasks
func listTasks(store: TaskStore) {
	if len(store.Tasks) == 0 {
		fmt.Println("No tasks yet!")
		return
	}

	fmt.Println("Tasks:")
	for _, task := range store.Tasks {
		let status = " "
		if task.Completed {
			status = "âœ“"
		}
		fmt.Printf("  [%s] %d: %s\n", status, task.ID, task.Description)
	}
}

// completeTask marks a task as complete
func completeTask(store: *TaskStore, id: int) error {
	for i, task := range store.Tasks {
		if task.ID == id {
			store.Tasks[i].Completed = true
			return nil
		}
	}
	return errors.New(fmt.Sprintf("task with ID %d not found", id))
}

// removeTask removes a task
func removeTask(store: *TaskStore, id: int) error {
	for i, task := range store.Tasks {
		if task.ID == id {
			// Remove task by slicing
			store.Tasks = append(store.Tasks[:i], store.Tasks[i+1:]...)
			return nil
		}
	}
	return errors.New(fmt.Sprintf("task with ID %d not found", id))
}
