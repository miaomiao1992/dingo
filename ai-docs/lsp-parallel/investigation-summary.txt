LSP PROXY ARCHITECTURE INVESTIGATION - SUMMARY

COMPLETION STATUS: ✅ COMPLETE

INVESTIGATION SCOPE:
- Go LSP proxy patterns and best practices
- JSON-RPC2 connection lifecycle (go.lsp.dev/jsonrpc2)
- Bidirectional communication in proxy scenarios
- Error handling and resilience patterns
- Position translation for meta-language transpilation
- Reference implementations and community patterns

KEY FINDINGS:

1. JSON-RPC2 Lifecycle
   - conn.Go() spawns non-blocking goroutine for message handling
   - Replier contract: Call exactly once per request
   - Can be called synchronously or asynchronously
   - Connection stays open until explicitly closed

2. Bidirectional Communication
   - Current implementation: Request/response only
   - Missing: Server-initiated messages (diagnostics, notifications)
   - Solution: Use ideConn.Notify() for unsolicited messages
   - Pattern: Reply to request once, send updates as notifications

3. Connection Shutdown
   - Correct sequence: Shutdown gopls → Wait → Close conn → Reply to IDE
   - Missing methods: gopls_client.Wait() and Close()
   - Need graceful cleanup to prevent deadlocks

4. Error Handling
   - Three error types: Handler error, malformed request, downstream error
   - jsonrpc2 handles malformed requests automatically
   - Downstream errors need careful propagation and retry logic

5. Position Translation
   - Bidirectional mapping: IDE (Dingo) ↔ gopls (Go)
   - Must translate both request and response positions
   - Need safe source map validation (missing/invalid handling)
   - Pattern: All response items must be translated

6. Reference Implementations
   - templ (github.com/a-h/templ): Best reference for proxy pattern
   - Source: cmd/lsp/server.go (~400 lines, clean implementation)
   - Pattern: Intercept requests, translate, forward, translate back
   - Key lessons: Position tracking, response translation

7. Common Pitfalls
   - Race conditions on Replier (call twice)
   - Deadlock on connection close (wrong shutdown order)
   - Context timeout issues (conn.Go needs long-lived context)
   - Lost responses in translation (incomplete item processing)

CURRENT STATE ASSESSMENT:

✅ GOOD:
  - Request routing and handler structure
  - Initial setup (stdio transport, jsonrpc2 init)
  - Error handling for malformed requests
  - Source map validation foundation

⚠️ PARTIAL:
  - Response translation (complete, but could be unified)
  - Shutdown handling (structure exists, but incomplete)

❌ MISSING:
  - Server-initiated messages (diagnostics publishing)
  - Complete shutdown methods (Wait, Close on gopls_client)
  - Concurrent access protection (mutex for ideConn)
  - Comprehensive response type translation

IMMEDIATE PRIORITIES (in order):

1. Implement ideConn.Notify() for diagnostics/messages
2. Add gopls_client.Wait() and Close() methods
3. Add sync.Mutex to protect concurrent ideConn access
4. Complete shutdown handler implementation
5. Create integration tests for bidirectional communication

ESTIMATED EFFORT:
- Priority 1-2: ~2-3 hours (straightforward pattern implementation)
- Priority 3-4: ~1-2 hours (cleanup and testing)
- Total: ~4-5 hours for complete implementation

CONFIDENCE LEVEL: HIGH
- Patterns are well-established and proven
- Implementation aligns with canonical LSP proxy architecture
- No novel or complex requirements
- Clear precedents in templ and gopls

FILES CREATED:
- minimax-prompt.md (investigation prompt, 280 lines)
- minimax-analysis.md (detailed analysis, 579 lines)
- investigation-summary.txt (this file)

NEXT STEPS:
1. Review full analysis: ai-docs/lsp-parallel/minimax-analysis.md
2. Study templ source: github.com/a-h/templ (cmd/lsp/server.go)
3. Implement Priority 1-2 changes
4. Add integration tests
5. Validate with manual testing in VS Code extension
