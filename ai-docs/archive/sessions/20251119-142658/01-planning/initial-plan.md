# Implementation Plan: Fix All 4 Priorities to Achieve 100% Test Passing

**Session**: 20251119-142658
**Date**: November 19, 2025
**Goal**: Implement all 4 priorities identified in previous session
**Estimated Total Time**: 11-16 hours

---

## Executive Summary

Based on the previous session's comprehensive analysis, we have 4 well-defined priorities to achieve 100% test passing:

1. **Priority 1**: Fix non-deterministic switch case generation (CRITICAL)
2. **Priority 2**: Fix preprocessor bugs in nested patterns (HIGH)
3. **Priority 3**: Fix 4 integration test failures (MEDIUM)
4. **Priority 4**: Enhance None inference for return statements (LOW)

**Current Status**: ~270/280+ tests passing (~96%)
**Target Status**: 267-280/280+ tests passing (98-100%)

---

## Priority 1: Fix Non-Deterministic Switch Case Generation

### Problem Statement
Pattern matching plugin generates switch cases in random order, causing golden tests to fail inconsistently even when the generated code is semantically correct.

### Impact
- **Tests Affected**: 4-5 pattern matching golden tests
- **Severity**: CRITICAL - Makes testing unreliable
- **Effort**: 2-3 hours

### Root Cause
In `pkg/plugin/builtin/pattern_match.go`, switch cases are generated by iterating over a Go map, which has non-deterministic iteration order.

### Implementation Details

**File to Modify**: `/Users/jack/mag/dingo/pkg/plugin/builtin/pattern_match.go`

**Current Behavior**:
```go
// Iterates over map with random order
for tag, pattern := range patternMap {
    generateCase(tag, pattern)
}
```

**Required Changes**:
1. **Identify case generation code** - Find where switch cases are created
2. **Extract tags to slice** - Collect all tags from the pattern map
3. **Sort deterministically** - Sort by tag value (alphabetically or numerically)
4. **Generate in order** - Iterate over sorted slice, not map

**Proposed Implementation**:
```go
// Step 1: Extract tags
tags := make([]string, 0, len(patternMap))
for tag := range patternMap {
    tags = append(tags, tag)
}

// Step 2: Sort deterministically
sort.Strings(tags)

// Step 3: Generate cases in order
for _, tag := range tags {
    pattern := patternMap[tag]
    generateCase(tag, pattern)
}
```

**Alternative Sorting Strategies**:
- **Alphabetical**: `sort.Strings(tags)` - Simple, predictable
- **Tag Value**: `sort.Slice(tags, func(i, j int) { return tagValue[i] < tagValue[j] })` - Semantic order
- **Preferred**: Alphabetical (simplest, matches Go conventions)

### Validation Strategy

**Step 1: Determinism Test**
```bash
# Run transpiler 10 times on same input
for i in {1..10}; do
  dingo build tests/golden/pattern_match_01_basic.dingo -o /tmp/test$i.go
done

# Check all outputs are identical
md5sum /tmp/test*.go | sort | uniq | wc -l  # Should output: 1
```

**Step 2: Golden Test Validation**
```bash
# Run golden tests multiple times
for i in {1..5}; do
  go test ./tests -run TestGoldenFiles/pattern_match -v
done
# All runs should have identical pass/fail results
```

**Step 3: Regression Check**
```bash
# Ensure no existing tests break
go test ./tests -run TestGoldenFiles -v
go test ./pkg/plugin/builtin -run TestPatternMatch -v
```

### Dependencies
- **None** - Can be implemented independently

### Parallel Execution
- ✅ **Can be done in parallel** with Priorities 2, 3, 4

### Expected Outcome
- **Tests Fixed**: 4-5 pattern matching golden tests pass consistently
- **Side Effect**: All future pattern matching tests will be deterministic
- **Success Metric**: 10 consecutive test runs produce identical results

---

## Priority 2: Fix Preprocessor Bugs (Nested Patterns)

### Problem Statement
Two test files fail to transpile due to preprocessor errors in handling nested pattern expressions:
- `pattern_match_03_nested.dingo`
- `pattern_match_06_guards_nested.dingo`

**Error Message**: "missing ',' in argument list"

### Impact
- **Tests Affected**: 2 tests
- **Severity**: HIGH - Blocks feature completion
- **Effort**: 3-4 hours

### Root Cause
The Rust match preprocessor (`pkg/preprocessor/rust_match.go`) has bugs in:
1. **Comma parsing** in nested expressions
2. **Expression boundary detection** for complex patterns

### Implementation Details

**File to Modify**: `/Users/jack/mag/dingo/pkg/preprocessor/rust_match.go`

**Investigation Steps**:

**Step 1: Reproduce the error**
```bash
# Try to transpile the failing files
dingo build tests/golden/pattern_match_03_nested.dingo 2>&1 | tee /tmp/error.log
dingo build tests/golden/pattern_match_06_guards_nested.dingo 2>&1 | tee -a /tmp/error.log
```

**Step 2: Identify the problematic pattern**
```bash
# Look at the actual Dingo code causing the error
cat tests/golden/pattern_match_03_nested.dingo
cat tests/golden/pattern_match_06_guards_nested.dingo
```

**Step 3: Debug the preprocessor**
- Add debug logging to `rust_match.go`
- Track expression parsing step-by-step
- Identify where comma detection fails

**Potential Bug Locations**:

**Bug A: `findExpressionEnd()` Function**
```go
// Current (buggy) - might not handle nested parens
func findExpressionEnd(expr string) int {
    depth := 0
    for i, ch := range expr {
        if ch == '(' { depth++ }
        if ch == ')' { depth-- }
        if depth == 0 && ch == ',' { return i }
    }
    return len(expr)
}

// Fixed - handle nested structures properly
func findExpressionEnd(expr string) int {
    depth := 0
    inString := false
    for i, ch := range expr {
        // Handle string literals
        if ch == '"' && (i == 0 || expr[i-1] != '\\') {
            inString = !inString
        }
        if inString { continue }

        // Track nesting depth
        if ch == '(' || ch == '[' || ch == '{' { depth++ }
        if ch == ')' || ch == ']' || ch == '}' { depth-- }

        // Found end of expression
        if depth == 0 && ch == ',' { return i }
    }
    return len(expr)
}
```

**Bug B: Greedy Regex Matching**
```go
// Current (buggy) - might be too greedy
pattern := regexp.MustCompile(`Ok\((.*)\)`)

// Fixed - non-greedy matching
pattern := regexp.MustCompile(`Ok\((.*?)\)`)
```

**Bug C: Nested Pattern Parsing**
```go
// May need to handle patterns like: Ok(Some(x))
// Current code might stop at first closing paren
```

### Proposed Implementation Approach

**Approach 1: Fix Expression Boundary Detection** (Recommended)
1. Enhance `findExpressionEnd()` to track all bracket types
2. Handle string literals properly
3. Handle escape sequences
4. Add comprehensive tests

**Approach 2: Rewrite Pattern Parser**
If bugs are too deep, consider:
1. State machine for pattern parsing
2. Recursive descent parser for nested patterns
3. More robust, but higher effort

**Recommended**: Start with Approach 1, escalate to Approach 2 if needed

### Validation Strategy

**Step 1: Fix and Test Locally**
```bash
# Modify rust_match.go with fix
# Test on failing files
dingo build tests/golden/pattern_match_03_nested.dingo
dingo build tests/golden/pattern_match_06_guards_nested.dingo
# Both should transpile successfully
```

**Step 2: Generate Golden Files**
```bash
# Create expected output files
dingo build tests/golden/pattern_match_03_nested.dingo -o tests/golden/pattern_match_03_nested.go.golden
dingo build tests/golden/pattern_match_06_guards_nested.dingo -o tests/golden/pattern_match_06_guards_nested.go.golden
```

**Step 3: Run Golden Tests**
```bash
go test ./tests -run TestGoldenFiles/pattern_match_03_nested -v
go test ./tests -run TestGoldenFiles/pattern_match_06_guards_nested -v
```

**Step 4: Regression Testing**
```bash
# Ensure all other pattern matching tests still pass
go test ./tests -run TestGoldenFiles/pattern_match -v
```

### Dependencies
- **Depends on**: Priority 1 (for deterministic output)
- **Reason**: Need deterministic generation before creating golden files

### Parallel Execution
- ⚠️ **Should run AFTER Priority 1** (requires deterministic output)
- ✅ **Can be done in parallel** with Priority 3 and 4

### Expected Outcome
- **Tests Fixed**: 2 tests (pattern_match_03_nested, pattern_match_06_guards_nested)
- **Side Effect**: All future nested patterns will work
- **Success Metric**: Both files transpile and golden tests pass

---

## Priority 3: Fix Integration Test Failures

### Problem Statement
Four Phase 4 integration tests are failing:
1. `TestIntegrationPhase4EndToEnd/pattern_match_rust_syntax`
2. `TestIntegrationPhase4EndToEnd/pattern_match_non_exhaustive_error`
3. `TestIntegrationPhase4EndToEnd/none_context_inference_return`
4. `TestIntegrationPhase4EndToEnd/combined_pattern_match_and_none`

### Impact
- **Tests Affected**: 4 integration tests
- **Severity**: MEDIUM - Integration coverage
- **Effort**: 2-3 hours (30-45 min per test)

### Root Cause
Each test likely has a different root cause. Requires individual investigation.

### Implementation Details

**File to Investigate**: `/Users/jack/mag/dingo/tests/integration_phase4_test.go`

**Investigation Approach** (Per Test):

#### Test 1: `pattern_match_rust_syntax`

**Step 1: Run and Capture Error**
```bash
go test ./tests -run TestIntegrationPhase4EndToEnd/pattern_match_rust_syntax -v 2>&1 | tee /tmp/test1.log
```

**Step 2: Analyze Failure**
- Is it a transpilation error? → Check preprocessor
- Is it a compilation error? → Check generated Go code
- Is it a runtime error? → Check logic transformation

**Step 3: Identify Root Cause**
- Compare expected vs actual output
- Check if related to Priority 1 (non-determinism)
- Check if related to Priority 2 (preprocessor bug)

**Step 4: Implement Fix**
- If preprocessor issue → Fix in `rust_match.go`
- If plugin issue → Fix in `pattern_match.go`
- If test issue → Update test expectations

#### Test 2: `pattern_match_non_exhaustive_error`

**Expected Behavior**: Should produce compile-time error for non-exhaustive matches

**Investigation**:
1. Does it fail to produce an error?
2. Does it produce wrong error message?
3. Does it produce error at wrong stage?

**Potential Issues**:
- Exhaustiveness checking logic in `pattern_match.go`
- Error reporting in `pkg/errors/`
- Test expectations incorrect

#### Test 3: `none_context_inference_return`

**Expected Behavior**: None should be inferred from return statement context

**Investigation**:
1. Is None being inferred correctly?
2. Is the type correct?
3. Is this related to Priority 4?

**Potential Issues**:
- Type inference not handling return statements
- Context detection missing for return statements
- This might be blocked until Priority 4 is complete

**Recommendation**:
- **Try fixing first** - Might be simple
- **If complex** - Defer until Priority 4 is done
- **If blocked by Priority 4** - Mark as dependent

#### Test 4: `combined_pattern_match_and_none`

**Expected Behavior**: Pattern matching and None inference work together

**Investigation**:
1. Which feature is failing?
2. Is it an interaction bug?
3. Is it a single feature bug?

**Potential Issues**:
- Pattern matching issue → Related to Priority 1 or 2
- None inference issue → Related to Priority 4
- Integration issue → New bug in feature interaction

**Strategy**:
- Fix Priorities 1 and 2 first
- Re-run this test
- If still failing → Investigate feature interaction
- If passing → Mark as resolved by other priorities

### Validation Strategy

**Step 1: Individual Test Validation**
```bash
# Fix each test individually
go test ./tests -run TestIntegrationPhase4EndToEnd/pattern_match_rust_syntax -v
go test ./tests -run TestIntegrationPhase4EndToEnd/pattern_match_non_exhaustive_error -v
go test ./tests -run TestIntegrationPhase4EndToEnd/none_context_inference_return -v
go test ./tests -run TestIntegrationPhase4EndToEnd/combined_pattern_match_and_none -v
```

**Step 2: Full Integration Suite**
```bash
# All Phase 4 integration tests
go test ./tests -run TestIntegrationPhase4EndToEnd -v
```

**Step 3: Regression Check**
```bash
# Ensure other integration tests still pass
go test ./tests -run TestIntegrationPhase2EndToEnd -v
```

### Dependencies
- **Test 1 & 2**: May depend on Priority 1 and 2
- **Test 3 & 4**: May depend on Priority 4
- **Recommendation**: Investigate each test independently, but expect some to auto-resolve

### Parallel Execution
- ⚠️ **Should run AFTER Priorities 1 & 2** (likely dependencies)
- ⚠️ **May need Priority 4** for tests 3 & 4
- ✅ **Individual test fixes can be done in parallel**

### Expected Outcome
- **Tests Fixed**: 4 integration tests
- **Possible Early Resolution**: Some tests may pass after Priority 1 & 2 fixes
- **Success Metric**: All 4 integration tests pass

---

## Priority 4: None Inference Enhancement (Return Statements)

### Problem Statement
None context inference doesn't handle return statements. Currently supports 5 context types, but missing return statement context.

### Impact
- **Tests Affected**: 1 test (none_context_inference_return)
- **Severity**: LOW - Nice-to-have enhancement
- **Effort**: 4-6 hours

### Root Cause
Type inference system (`pkg/plugin/builtin/type_inference.go`) doesn't have logic to infer types from function return signatures.

### Implementation Details

**Files to Modify**:
- `/Users/jack/mag/dingo/pkg/plugin/builtin/type_inference.go`
- `/Users/jack/mag/dingo/pkg/plugin/builtin/type_inference_context_test.go`

**Current Context Types** (5):
1. Variable assignment: `var x Option<int> = None`
2. Function parameter: `foo(None)`
3. Map value: `m["key"] = None`
4. Slice element: `s[0] = None`
5. Struct field: `obj.field = None`

**Missing Context Type** (6th):
6. Return statement: `return None`

### Investigation Steps

**Step 1: Understand Current Implementation**
```bash
# Read type inference code
cat pkg/plugin/builtin/type_inference.go | grep -A 20 "func.*Context"
```

**Step 2: Identify Return Statement Detection**
```go
// Need to find if statement is a return statement
// Then get function's return type signature
```

**Step 3: Design AST Traversal**
```go
// For return statement, need to:
// 1. Find parent function declaration
// 2. Extract return type from function signature
// 3. Match return value position to type
```

### Proposed Implementation

**Phase A: AST Parent Tracking Enhancement**

The session notes mention AST parent tracking was implemented (<10ms). Verify it exists and is accessible.

```go
// In type_inference.go
func inferFromReturnStatement(node *ast.ReturnStmt, info *types.Info) (types.Type, error) {
    // Step 1: Get parent function using AST parent tracking
    funcDecl := findParentFunction(node)
    if funcDecl == nil {
        return nil, errors.New("return statement not in function")
    }

    // Step 2: Get function signature
    funcType := info.TypeOf(funcDecl.Type).(*types.Signature)

    // Step 3: Match return value position
    returnTypes := funcType.Results()

    // Step 4: Find position of None in return statement
    nonePos := findNonePosition(node)

    // Step 5: Return corresponding type
    if nonePos < returnTypes.Len() {
        return returnTypes.At(nonePos).Type(), nil
    }

    return nil, errors.New("cannot infer type from return")
}
```

**Phase B: Integration into Inference Pipeline**

```go
// Add to existing inference function
func InferNoneType(node ast.Node, info *types.Info) (types.Type, error) {
    switch n := node.(type) {
    case *ast.AssignStmt:
        return inferFromAssignment(n, info)
    case *ast.CallExpr:
        return inferFromFunctionCall(n, info)
    // ... existing cases ...
    case *ast.ReturnStmt:  // NEW
        return inferFromReturnStatement(n, info)
    default:
        return nil, errors.New("unknown context")
    }
}
```

**Phase C: AST Parent Tracking Utility**

```go
// Utility to find parent function
func findParentFunction(node ast.Node) *ast.FuncDecl {
    // Use AST parent tracking (implemented in Phase 4.1)
    // Walk up the tree until we find *ast.FuncDecl
    parent := getParent(node)
    for parent != nil {
        if funcDecl, ok := parent.(*ast.FuncDecl); ok {
            return funcDecl
        }
        parent = getParent(parent)
    }
    return nil
}
```

### Example Usage

**Input Dingo Code**:
```go
func getDefault() Option<int> {
    return None  // Should infer Option<int>
}

func processData() (Option<string>, error) {
    if someCondition {
        return None, nil  // Should infer Option<string>
    }
    return Some("data"), nil
}
```

**Expected Behavior**:
1. Parser encounters `return None`
2. Inference finds parent function `getDefault`
3. Extracts return type: `Option<int>`
4. Transforms `None` → `None[int]()`

### Validation Strategy

**Step 1: Unit Tests**
```bash
# Test type inference for return statements
go test ./pkg/plugin/builtin -run TestTypeInference.*Return -v
```

**Step 2: Golden Test**
```bash
# Create/update golden test
cat > tests/golden/option_07_return_inference.dingo << 'EOF'
package main

func getDefault() Option<int> {
    return None
}

func getTuple() (Option<string>, Option<int>) {
    return None, None
}
EOF

# Generate golden file
dingo build tests/golden/option_07_return_inference.dingo -o tests/golden/option_07_return_inference.go.golden

# Run test
go test ./tests -run TestGoldenFiles/option_07_return_inference -v
```

**Step 3: Integration Test**
```bash
# This should now pass
go test ./tests -run TestIntegrationPhase4EndToEnd/none_context_inference_return -v
```

**Step 4: Regression Check**
```bash
# Ensure existing None inference still works
go test ./tests -run TestGoldenFiles/option_06_none_inference -v
go test ./pkg/plugin/builtin -run TestTypeInference -v
```

### Dependencies
- **None** - Can be implemented independently
- **Note**: Integration test (Priority 3, Test 3) depends on this

### Parallel Execution
- ✅ **Can be done in parallel** with all other priorities
- **Note**: Priority 3 Test 3 should re-run after this completes

### Expected Outcome
- **Tests Fixed**: 1 integration test (none_context_inference_return)
- **Feature Complete**: None inference now supports all 6 context types
- **Success Metric**: Return statement None inference works correctly

---

## Execution Strategy

### Phase 1: Parallel Foundation Work (Hours 1-4)

**Launch 3 agents in parallel**:

**Agent A: Priority 1** (golang-developer)
- Fix non-deterministic switch case generation
- Implement sorted case generation
- Validate determinism
- **Deliverable**: Deterministic pattern match plugin

**Agent B: Priority 4** (golang-developer)
- Implement return statement type inference
- Add return context detection
- Create unit tests
- **Deliverable**: Working return statement None inference

**Agent C: Priority 3 Investigation** (golang-developer)
- Run all 4 integration tests
- Capture error logs
- Document failure modes
- Identify dependencies
- **Deliverable**: Analysis report for each test

**Estimated Time**: 2-4 hours

---

### Phase 2: Sequential Fixes (Hours 5-8)

**After Agent A completes (Priority 1)**:

**Agent D: Priority 2** (golang-developer)
- Fix preprocessor bugs (requires deterministic output from Priority 1)
- Generate golden files for 03 and 06
- Validate transpilation
- **Deliverable**: 2 new golden tests passing

**Estimated Time**: 3-4 hours

---

### Phase 3: Integration Test Resolution (Hours 9-11)

**After Agent B and D complete**:

**Agent E: Priority 3 Implementation** (golang-developer)
- Fix each integration test based on Agent C's analysis
- Some may auto-resolve from Priority 1 & 2 fixes
- Apply Priority 4 (return inference) if needed
- **Deliverable**: 4 integration tests passing

**Estimated Time**: 2-3 hours

---

### Phase 4: Final Validation (Hours 12-13)

**Full Test Suite Run**:
```bash
# Run complete test suite
go test ./tests -v | tee final-test-results.txt

# Run multiple times to verify determinism
for i in {1..5}; do
  go test ./tests -run TestGoldenFiles/pattern_match -v
done
```

**Create Test Report**:
- Document final pass/fail counts
- Compare to starting point (270/280)
- Identify any remaining failures
- Categorize remaining work (if any)

**Estimated Time**: 1-2 hours

---

## Risk Analysis

### Risk 1: Preprocessor Bugs More Complex Than Expected
**Probability**: Medium
**Impact**: High
**Mitigation**:
- Allocate extra time buffer (4-6 hours instead of 3-4)
- Consider rewrite if fixes too fragile
- Escalate to external model consultation if stuck

### Risk 2: Integration Tests Have Unknown Dependencies
**Probability**: Medium
**Impact**: Medium
**Mitigation**:
- Early investigation (Agent C) to identify dependencies
- May need to defer some tests if blocked
- Document dependencies clearly

### Risk 3: Return Inference More Complex Than Expected
**Probability**: Low
**Impact**: Low
**Mitigation**:
- Only affects 1 test
- Can defer if needed
- Low priority, won't block 100% goal

### Risk 4: New Test Failures Introduced
**Probability**: Low
**Impact**: High
**Mitigation**:
- Run regression tests after each priority
- Validate golden tests haven't broken
- Keep git commits atomic (one priority per commit)

---

## Success Metrics

### Minimum Success (95%+)
- ✅ Priority 1 complete: Deterministic output
- ✅ Priority 2 complete: 2 preprocessor bugs fixed
- ✅ 2/4 integration tests passing
- **Result**: ~275/280 tests (98%)

### Target Success (98%+)
- ✅ Priority 1 complete
- ✅ Priority 2 complete
- ✅ 3/4 integration tests passing
- ⚠️ Priority 4 partial
- **Result**: ~277/280 tests (99%)

### Stretch Success (100%)
- ✅ All 4 priorities complete
- ✅ All integration tests passing
- ✅ All golden tests passing
- **Result**: 280/280 tests (100%)

---

## Deliverables

### Code Changes
1. `pkg/plugin/builtin/pattern_match.go` - Deterministic case generation
2. `pkg/preprocessor/rust_match.go` - Nested pattern fixes
3. `pkg/plugin/builtin/type_inference.go` - Return statement inference
4. `tests/golden/pattern_match_03_nested.go.golden` - New golden file
5. `tests/golden/pattern_match_06_guards_nested.go.golden` - New golden file
6. `tests/integration_phase4_test.go` - Fixed integration tests

### Documentation
1. **Test Results Report**: Final pass/fail analysis
2. **Implementation Notes**: Decisions made during implementation
3. **Regression Validation**: Proof no tests broke
4. **Performance Metrics**: Determinism validation results

### Session Artifacts
```
ai-docs/sessions/20251119-142658/
├── 01-planning/
│   ├── initial-plan.md (this file)
│   └── gaps.json
├── 02-implementation/
│   ├── priority1-changes.md
│   ├── priority2-changes.md
│   ├── priority3-changes.md
│   └── priority4-changes.md
├── 03-testing/
│   ├── determinism-validation.txt
│   ├── regression-results.txt
│   └── final-test-report.md
└── FINAL-SESSION-SUMMARY.md
```

---

## Timeline Estimate

| Phase | Duration | Deliverable |
|-------|----------|-------------|
| Planning (this document) | 1 hour | Implementation plan |
| Phase 1: Parallel work | 2-4 hours | Priorities 1, 4, investigation |
| Phase 2: Sequential fixes | 3-4 hours | Priority 2 |
| Phase 3: Integration fixes | 2-3 hours | Priority 3 |
| Phase 4: Validation | 1-2 hours | Final test report |
| **Total** | **9-14 hours** | **100% test passing** |

**Buffer**: +2 hours for unexpected issues
**Realistic Total**: 11-16 hours

---

## Next Steps (Immediate)

1. **Review this plan** with user for approval
2. **Answer any questions** in `gaps.json`
3. **Launch Phase 1** agents in parallel:
   - Agent A: Priority 1
   - Agent B: Priority 4
   - Agent C: Priority 3 investigation
4. **Track progress** with session artifacts
5. **Report status** after each phase

---

**Plan Status**: COMPLETE
**Confidence Level**: HIGH (95%)
**Recommended Action**: Proceed with Phase 1 execution
