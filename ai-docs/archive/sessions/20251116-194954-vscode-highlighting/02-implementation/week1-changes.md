# Week 1 Implementation: Transpiler Marker Injection

## Overview
Implemented block-level marker comments in generated Go code to identify transpiler-generated sections for future VSCode syntax highlighting.

## Files Modified

### 1. `/Users/jack/mag/dingo/pkg/plugin/plugin.go`
**Changes:**
- Added `EmitGeneratedMarkers bool` field to `Config` struct
- Enables/disables marker generation in generated code
- Defaults to `true` (enabled)

**Purpose:** Provides configuration flag for controlling marker injection across all plugins.

### 2. `/Users/jack/mag/dingo/pkg/generator/generator.go`
**Changes:**
- Updated `NewWithPlugins()` to initialize `EmitGeneratedMarkers: true` by default
- Added Step 5 in `Generate()` method: marker injection post-processing
- Creates `MarkerInjector` and calls `InjectMarkers()` on formatted code
- Handles marker injection failures gracefully

**Purpose:** Integrates marker injection into the code generation pipeline as a post-processing step after AST printing and formatting.

### 3. `/Users/jack/mag/dingo/pkg/generator/markers.go` (NEW FILE)
**Changes:**
- Created `MarkerInjector` struct with enabled flag
- Implemented `InjectMarkers()` method using regex pattern matching
- Detects error propagation patterns (`if __err\d+ != nil { return ... }`)
- Wraps detected blocks with `// DINGO:GENERATED:START error_propagation` and `// DINGO:GENERATED:END`
- Preserves indentation from original code
- Helper function `getIndentation()` for extracting line indentation

**Purpose:** Post-processing engine that injects marker comments into generated Go source code without modifying the AST.

### 4. `/Users/jack/mag/dingo/pkg/generator/markers_test.go` (NEW FILE)
**Changes:**
- Created comprehensive unit tests for `MarkerInjector`
- Tests for enabled/disabled marker injection
- Tests for single and multiple error propagation blocks
- Tests for indentation handling
- All tests passing

**Purpose:** Ensures marker injection works correctly and can be toggled via configuration.

### 5. `/Users/jack/mag/dingo/pkg/plugin/builtin/error_propagation.go`
**Changes:**
- Added `currentContext *plugin.Context` field to store transformation context
- Updated `Transform()` to store context in `p.currentContext`
- Added `wrapWithMarkers()` method (currently a no-op, ready for future AST-level markers)
- Added helper types for potential AST-based markers (for future enhancement)

**Purpose:** Prepares error propagation plugin for marker support and stores context for configuration access.

## Marker Format

Generated markers follow this format:

```go
// DINGO:GENERATED:START error_propagation
if __err0 != nil {
    return nil, __err0
}
// DINGO:GENERATED:END
```

### Marker Types
- `error_propagation` - Marks code generated by `?` operator transformations
- Extensible for future features (pattern matching, Option types, etc.)

## Implementation Approach

**Why Post-Processing?**

Instead of modifying the AST to include comments (which is complex in Go's ast package), we use a pragmatic post-processing approach:

1. AST generates clean Go code
2. Code is formatted with `go fmt`
3. Regex pattern matching identifies generated blocks by their signature patterns (e.g., `__err0`, `__err1` variables)
4. Markers are injected around identified blocks
5. Indentation is preserved

**Advantages:**
- Simple and reliable
- Survives `go fmt` (markers are valid Go comments)
- No complex AST comment map handling
- Easy to extend for new patterns

**Trade-offs:**
- Relies on pattern matching (could have false positives if user code uses `__err` variables)
- Post-processing adds small overhead
- Not as precise as AST-level markers

## Configuration

Users can disable markers via plugin config:

```go
ctx := &plugin.Context{
    Config: &plugin.Config{
        EmitGeneratedMarkers: false,  // Disable markers
    },
    // ...
}
```

Default: `true` (enabled)

## Testing

### Tests Created
- `TestMarkerInjector_InjectMarkers` - Core functionality
- `TestGetIndentation` - Helper function
- All tests passing ✓

### Test Coverage
- Disabled markers (no injection)
- Single error propagation block
- Multiple error propagation blocks
- Indentation preservation

## Known Limitations

1. **Pattern-based detection**: Currently uses regex to detect `__err` patterns. If user code manually uses `__err` variables, they might get incorrectly marked.

2. **Post-processing only**: Markers are added after code generation, not during AST transformation. This means:
   - Cannot access AST context for more precise marker placement
   - Relies on output pattern signatures

3. **Error propagation only**: Only marks error propagation blocks in Week 1. Future weeks will add markers for other generated constructs.

## Future Enhancements (Post Week 1)

1. **AST-level markers**: Implement proper `ast.CommentMap` integration for more precise marker placement
2. **Additional marker types**: Add markers for pattern matching, Option types, etc.
3. **Marker metadata**: Include source positions, transformation types, etc.
4. **Configuration**: Add more granular control (per-feature marker toggles)

## Integration with VSCode (Week 2+)

These markers will be consumed by the VSCode extension to:
- Apply different syntax highlighting to generated code
- Provide hover tooltips explaining transformations
- Enable "Go to Dingo source" navigation
- Show/hide generated blocks in editor

## Verification

To verify markers are working:

1. Build a Dingo file with `?` operator
2. Check generated `.go` file
3. Look for `// DINGO:GENERATED:START` and `// DINGO:GENERATED:END` comments around error checks

Example:
```dingo
func fetchUser(id int) (*User, error) {
    db := connect()?
    user := db.query(id)?
    return user, nil
}
```

Generated Go (with markers):
```go
func fetchUser(id int) (*User, error) {
    db, __err0 := connect()
    // DINGO:GENERATED:START error_propagation
    if __err0 != nil {
        return nil, __err0
    }
    // DINGO:GENERATED:END
    user, __err1 := db.query(id)
    // DINGO:GENERATED:START error_propagation
    if __err1 != nil {
        return nil, __err1
    }
    // DINGO:GENERATED:END
    return user, nil
}
```

## Conclusion

Week 1 successfully implements marker injection foundation:
- ✅ Configuration flag added
- ✅ Marker injection integrated into generator pipeline
- ✅ Error propagation blocks marked
- ✅ Tests passing
- ✅ Extensible architecture for future marker types
- ✅ Ready for Week 2 VSCode integration
