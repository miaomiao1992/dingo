# Internal Architect Investigation: Golden Test Failures

## Executive Summary

**Root Cause**: The `// dingo:s:N` start markers ARE being generated by the preprocessor (`pkg/preprocessor/error_prop.go` lines 385-395), but they are being **stripped during AST processing** because `go/printer` doesn't preserve all comment associations after AST transformations.

**Source of Truth**: **Golden files are PARTIALLY correct** - they should contain `// dingo:s:N` markers, but they have OTHER bugs (duplicate markers, unqualified imports). The transpiler output is MORE correct (compilable Go), but missing start markers.

**Recommended Fix**: Fix the transpiler's comment preservation during AST printing, then regenerate golden files.

---

## Root Cause Analysis

### The Comment Loss Mystery

I traced the execution flow and discovered:

1. **Preprocessor DOES generate start markers** ✅
   - File: `pkg/preprocessor/error_prop.go` lines 385-395
   - Code explicitly writes `// dingo:s:1` between the assignment and `if` statement
   - Test confirms: preprocessor output contains both `// dingo:s:1` and `// dingo:e:1`

2. **go/parser PRESERVES comments when parsing** ✅
   - File: `pkg/parser/parser_new.go` line 42
   - Uses `parser.ParseComments` flag correctly
   - Test confirms: comments survive parsing and `go/format.Source()`

3. **Comments ARE LOST during AST transformation/printing** ❌
   - File: `pkg/generator/generator.go` lines 175-222
   - AST is transformed by plugin pipeline before printing
   - **Problem**: When AST nodes are modified/replaced, their associated comments are orphaned
   - `go/printer` doesn't know where to reattach orphaned comments

### Technical Details

**Why comments get lost:**

The preprocessor generates this:
```go
__tmp0, __err0 := os.ReadFile(path)
// dingo:s:1
if __err0 != nil {
```

When `go/parser` parses this:
- `// dingo:s:1` is attached to the file's `Comments` slice
- It's associated with the `IfStmt` node based on position

When plugins transform the AST:
- Nodes may be replaced/modified
- Comment associations are based on original positions
- If a plugin creates new nodes or moves nodes, comments don't follow
- `go/printer` only prints comments that are in `file.Comments` AND can determine position

**Result**: The `// dingo:s:1` comment exists in `file.Comments`, but `go/printer` can't determine WHERE to print it after transformations, so it gets silently dropped.

---

## Source of Truth Decision

**Neither current golden files NOR current transpiler output are 100% correct.**

### Golden Files Are Wrong Because:

1. ❌ **Duplicate `// dingo:s:1` markers**
   - Some files have TWO start markers (clearly a copy-paste bug)

2. ❌ **Unqualified function calls**
   - `ReadFile(path)` instead of `os.ReadFile(path)`
   - This is NOT valid Go - won't compile
   - Looks like golden files were written before unqualified import inference was implemented

3. ❌ **Single-line vs multi-line import formatting**
   - Golden: `import "os"`
   - Transpiler: `import (\n\t"os"\n)`
   - This is COSMETIC ONLY - both are valid Go
   - `go/format` defaults to multi-line, which is standard Go style

### Transpiler Output Is Wrong Because:

1. ❌ **Missing `// dingo:s:1` start markers**
   - Critical for source mapping
   - LSP server needs these for accurate error position translation

2. ✅ **But everything else is CORRECT:**
   - Qualified imports (`os.ReadFile` not `ReadFile`)
   - Proper import formatting
   - No duplicate markers
   - Compilable Go code

### Recommendation: **Transpiler is the source of truth AFTER we fix comment preservation**

**Plan:**
1. Fix comment preservation in AST printing (see Implementation Plan below)
2. Regenerate ALL golden files from corrected transpiler
3. Add validation: golden files MUST compile with `go build`

---

## Source Map Comments Analysis

### Purpose of `// dingo:s:N` and `// dingo:e:N`

**Purpose**: Enable accurate source position mapping for LSP server

**Use case**:
```
Dingo source (line 4):
  let data = ReadFile(path)?

Transpiled Go (lines 8-14):
  __tmp0, __err0 := os.ReadFile(path)  // line 8
  // dingo:s:1                          // line 9 <-- START MARKER
  if __err0 != nil {                    // line 10
      return nil, __err0                // line 11
  }                                     // line 12
  // dingo:e:1                          // line 13 <-- END MARKER
  var data = __tmp0                     // line 14
```

**When Go compiler reports error at line 11:**
1. LSP server sees `// dingo:s:1` at line 9
2. Knows lines 9-13 map to 1 original Dingo line
3. Translates Go line 11 → Dingo line 4
4. IDE shows error at correct position in `.dingo` file

### Why We Need BOTH Markers

- **Start marker** (`// dingo:s:1`): Marks beginning of expanded block
- **End marker** (`// dingo:e:1`): Marks end of expanded block
- **Number after ':'**: How many original lines consumed (always `1` for `?` operator)

**Currently missing**: Only end markers are present, so LSP can't determine START of expanded blocks.

### Critical or Optional?

**CRITICAL** ✅

Without start markers:
- ❌ Can't accurately map Go errors back to Dingo source
- ❌ LSP "Go to Definition" breaks
- ❌ Debugging in IDE shows wrong line numbers
- ❌ Error messages point to wrong Dingo lines

The entire value proposition of Dingo's LSP server depends on these markers.

---

## Implementation Plan

### Priority 1: CRITICAL - Fix Comment Preservation

**File**: `pkg/generator/generator.go`

**Problem**: AST transformations orphan comments

**Solution**: Explicitly preserve and reattach comment groups after transformations

**Code changes**:

```go
// In Generate() function, after line 150 (after pipeline.Transform):

// Step 4.5: Reattach orphaned comments (Fix for missing dingo:s: markers)
if g.pipeline != nil {
	reattachOrphanedComments(file.File, transformed)
}
```

**New function to add**:

```go
// reattachOrphanedComments ensures comment groups survive AST transformations
// This fixes the issue where // dingo:s:N markers disappear during printing
func reattachOrphanedComments(originalFile, transformedFile *ast.File) {
	// Preserve all comment groups from original file
	// go/printer will use file.Comments when printing
	if originalFile != nil && len(originalFile.Comments) > 0 {
		// Copy comment groups to transformed file
		transformedFile.Comments = originalFile.Comments
	}
}
```

**Why this works**:
- `go/parser` stores ALL comments in `file.Comments` slice
- `go/printer` prints comments from this slice in position order
- By copying comments from original to transformed file, we ensure markers survive
- Position-based association works because we're not changing line positions of error handling blocks

**Confidence**: HIGH (90%) - Standard approach for comment preservation in Go AST tools

### Priority 2: CRITICAL - Regenerate Golden Files

**Steps**:

1. **After fixing comment preservation**, run:
   ```bash
   go test ./tests -run TestGoldenFiles -update-golden
   ```

2. **Validate ALL generated files compile**:
   ```bash
   for f in tests/golden/*.go; do
       go build -o /dev/null "$f" || echo "FAILED: $f"
   done
   ```

3. **Manually review diff** to ensure:
   - ✅ `// dingo:s:1` markers present
   - ✅ `// dingo:e:1` markers present
   - ✅ NO duplicate markers
   - ✅ Qualified imports (`os.ReadFile` not `ReadFile`)
   - ✅ Proper import formatting

**Files to update**: All `.go.golden` files in `tests/golden/`

### Priority 3: MINOR - Import Formatting

**Issue**: Single-line vs multi-line imports

**Current golden files**:
```go
import "os"
```

**Transpiler output**:
```go
import (
    "os"
)
```

**Decision**: Accept transpiler output (multi-line is standard Go style)

**Rationale**:
- `go/format` defaults to multi-line
- Standard Go convention
- Matches `gofmt` behavior
- NOT worth custom formatting logic

**Action**: When regenerating golden files, accept multi-line format

### Priority 4: VALIDATION - Add Compile Check to Tests

**File**: `tests/golden_test.go`

**Add validation step**:

```go
func TestGoldenFilesCompile(t *testing.T) {
	goldenFiles, _ := filepath.Glob("golden/*.go.golden")

	for _, goldenFile := range goldenFiles {
		t.Run(filepath.Base(goldenFile), func(t *testing.T) {
			// Read golden file
			content, err := os.ReadFile(goldenFile)
			require.NoError(t, err)

			// Try to parse it (ensures syntactically valid Go)
			fset := token.NewFileSet()
			_, err = parser.ParseFile(fset, goldenFile, content, parser.AllErrors)
			require.NoError(t, err, "Golden file must be valid Go syntax")

			// Optional: Try to type-check it
			// (This ensures imports are correct, types are valid, etc.)
		})
	}
}
```

**Purpose**: Ensure golden files contain compilable Go, not template-like pseudocode

---

## Code Locations

### Files Involved:

| File | Role | Lines of Interest |
|------|------|------------------|
| `pkg/preprocessor/error_prop.go` | Generates markers | 385-395, 435-445 |
| `pkg/generator/generator.go` | AST transformation & printing | 109-257 |
| `pkg/generator/markers.go` | Marker injection (post-processing) | 30-64 |
| `pkg/parser/parser_new.go` | Parses with comments | 42 |
| `cmd/dingo/main.go` | Build command flow | 201-282 |
| `tests/golden/*.go.golden` | Expected output (need regeneration) | All files |

### Key Functions:

1. **Preprocessor marker generation**:
   - `expandAssignment()` - lines 385-395
   - `expandReturn()` - lines 435-445

2. **Generator AST handling**:
   - `Generate()` - main orchestration (lines 109-257)
   - `removeBlankLinesAroundDingoMarkers()` - cleanup (lines 332-360)

3. **Parser**:
   - `NewParser()` → `ParseFile()` with `parser.ParseComments` flag

---

## Alternatives Considered

### Alternative 1: Inject markers in post-processing (current approach in markers.go)

**How it works**: After AST generation, use regex to find error handling blocks and inject markers

**File**: `pkg/generator/markers.go` lines 30-64

**Status**: Currently implemented but SKIPPED if markers already exist (line 40)

**Problem**:
- Preprocessor generates markers
- They survive parsing
- They're lost during AST transformation
- Post-processor detects existing markers and skips injection
- Result: No markers in final output

**Why not use this**: Chicken-and-egg problem. Post-processor sees `// dingo:e:1` (which survives) and assumes `// dingo:s:1` is also present.

### Alternative 2: Don't use comments, use AST metadata

**Approach**: Store source mappings in separate `.sourcemap` file, not as comments

**Pros**:
- No comment preservation issues
- Cleaner generated Go code
- Industry standard (JavaScript source maps)

**Cons**:
- Requires separate `.sourcemap` file management
- LSP server must read two files
- More complex implementation

**Decision**: Keep comments approach, but fix preservation

**Rationale**:
- Comments are simpler
- Self-contained (Go file has all mapping data)
- Already implemented, just needs fix

### Alternative 3: Generate markers AFTER AST transformation

**Approach**: Don't generate markers in preprocessor. Generate them after AST transformation by detecting error handling patterns.

**Implementation**: Enhance `markers.go` to detect error handling blocks more robustly

**Pros**:
- No comment preservation issues
- Markers can't get lost

**Cons**:
- Requires pattern matching on transformed AST
- Less reliable (what if AST structure changes?)
- Doesn't solve the general comment preservation problem

**Decision**: Fix root cause (comment preservation) rather than workaround

---

## Validation Strategy

### Before Implementing Fix:

1. ✅ Confirmed preprocessor generates markers (test passed)
2. ✅ Confirmed `go/parser` preserves comments (test passed)
3. ✅ Confirmed markers disappear during AST transformation (observed)

### After Implementing Fix:

1. **Unit test**: Verify `reattachOrphanedComments()` works
   ```go
   func TestCommentPreservation(t *testing.T) {
       // Parse Go source with dingo markers
       // Transform AST
       // Verify markers still present in output
   }
   ```

2. **Integration test**: Run golden test suite
   ```bash
   go test ./tests -run TestGoldenFiles
   ```

3. **Compilation test**: Ensure all golden files compile
   ```bash
   go test ./tests -run TestGoldenFilesCompile
   ```

4. **Manual verification**: Build showcase example and inspect output
   ```bash
   go run cmd/dingo/main.go build tests/golden/showcase_01_api_server.dingo
   grep "dingo:s:" tests/golden/showcase_01_api_server.go
   grep "dingo:e:" tests/golden/showcase_01_api_server.go
   ```

---

## Confidence Level

**HIGH (90%)**

**Why high confidence:**

1. ✅ Root cause clearly identified (comment orphaning during AST transformation)
2. ✅ Standard solution exists (comment reattachment)
3. ✅ Evidence-based analysis (tested each stage of pipeline)
4. ✅ Low-risk fix (adding comments doesn't change AST semantics)
5. ✅ Clear validation path (tests will confirm fix works)

**Remaining 10% uncertainty:**

1. ⚠️ Possible edge cases in complex transformations (nested error propagation)
2. ⚠️ Comment position mapping may need refinement for multi-line expressions
3. ⚠️ Plugin pipeline may have other comment-sensitive operations

**Mitigation**:
- Start with simple `reattachOrphanedComments()` implementation
- Run full test suite
- If issues arise, add more sophisticated position-based comment mapping

---

## Next Steps

1. **Implement** `reattachOrphanedComments()` in `pkg/generator/generator.go`
2. **Test** with single golden file: `error_prop_01_simple.dingo`
3. **Validate** markers appear in output
4. **Run** full golden test suite
5. **Regenerate** all golden files with `-update-golden` flag
6. **Add** compile validation test
7. **Commit** with message: "fix(generator): Preserve source map comments during AST transformation"

---

## Appendix: Evidence

### Evidence 1: Preprocessor generates markers

**Test run**:
```bash
$ go run /tmp/test_dingo.go
__tmp0, __err0 := ReadFile(path)
// dingo:s:1                    <-- PRESENT
if __err0 != nil {
    return nil, __err0
}
// dingo:e:1                    <-- PRESENT
var data = __tmp0
```

### Evidence 2: go/parser preserves comments

**Test run**:
```bash
$ go run /tmp/test_parser.go
=== Comment Groups ===
Position: 5, Text: // dingo:s:1    <-- PRESENT after parsing
Position: 9, Text: // dingo:e:1    <-- PRESENT after parsing
```

### Evidence 3: Transpiler output missing start marker

**Actual transpiled file**:
```go
__tmp0, __err0 := os.ReadFile(path)

if __err0 != nil {              <-- NO // dingo:s:1 here
    return nil, __err0
}
// dingo:e:1                    <-- END marker present
var data = __tmp0
```

**Conclusion**: Markers are lost between parsing and printing, during AST transformation phase.

---

## References

- Go AST package docs: https://pkg.go.dev/go/ast
- Go printer package docs: https://pkg.go.dev/go/printer
- Comment preservation pattern: https://github.com/golang/go/issues/20744
- Source maps spec (for context): https://sourcemaps.info/spec.html
