[
  {
    "question": "Should we prioritize Task 1 (4 context helpers) over Task 4 (guards), or implement all tasks in parallel?",
    "rationale": "Task 1 is foundational and enables Tasks 2 & 3. Task 4 is independent. Sequential implementation (1→2→3→4) reduces risk but takes longer. Parallel implementation (1+4, then 2+3) is faster but requires coordination."
  },
  {
    "question": "What is the acceptable fallback behavior when go/types.Info is unavailable?",
    "rationale": "Tasks 1-3 rely heavily on go/types for accurate type resolution. If go/types is not available (e.g., early transpilation stage), should we: (a) Fail with error, (b) Use parseTypeExpr() fallback and warn, or (c) Skip type inference silently?"
  },
  {
    "question": "Should guard validation be strict (compile error on invalid guard) or permissive (warning only)?",
    "rationale": "Task 4 involves validating guard expressions. Strict validation catches errors early but may block valid code. Permissive validation allows experimentation but may cause runtime issues. What's the preferred approach?"
  },
  {
    "question": "Is there a maximum parent chain depth we should enforce for performance?",
    "rationale": "Context inference in Task 1 walks up the AST parent chain. Deeply nested code (20+ levels) could cause performance issues. Should we: (a) Set a hard limit (e.g., 20 levels), (b) Add timeout, or (c) Unlimited traversal with logging?"
  },
  {
    "question": "Should we support guard expressions that reference external variables/functions?",
    "rationale": "Task 4 guard validation checks if guards only use pattern-bound variables. However, real guards might need: `if x > threshold` where `threshold` is from outer scope. Should we: (a) Restrict to bound vars only, (b) Allow outer scope references, or (c) Require explicit capture?"
  },
  {
    "question": "What error message format do you prefer when None/Err() type inference fails?",
    "rationale": "When context inference fails, we need helpful error messages. Options: (a) Rustc-style with code snippet and suggestion, (b) Simple one-liner with position, (c) Detailed multi-line with all attempted contexts. Which style matches Dingo's error philosophy?"
  },
  {
    "question": "Should parseTypeExpr() handle all Go type expressions or just common cases?",
    "rationale": "Task 1.5 implements fallback type parsing. Full support requires handling: channels, function types, structs, interfaces, etc. This is complex. Should we: (a) Implement full support, (b) Support only basic types + pointers + slices, or (c) Return error for unsupported types?"
  },
  {
    "question": "Do you want parallel implementation of Task 1 helpers, or sequential (one at a time)?",
    "rationale": "Task 1 has 4 sub-tasks (1.1-1.4). Sequential implementation allows thorough testing of each helper before moving on. Parallel implementation is faster but may introduce integration issues. What's preferred?"
  },
  {
    "question": "Should we cache type inference results to improve performance?",
    "rationale": "Multiple plugins may call InferTypeFromContext() on the same nodes. Caching could reduce overhead from 15ms to <5ms per file. However, cache invalidation adds complexity. Should we: (a) Implement aggressive caching, (b) No caching (simplicity), or (c) Cache only expensive operations?"
  },
  {
    "question": "How should we handle ambiguous contexts (e.g., None in ternary expressions)?",
    "rationale": "Some contexts may provide conflicting type hints. Example: `x = condition ? None : Some(\"str\")` - None could be inferred from assignment target OR from sibling Some(). Which takes precedence? Should we: (a) Use strict precedence order, (b) Validate consistency and error if mismatch, or (c) Pick first match?"
  }
]
