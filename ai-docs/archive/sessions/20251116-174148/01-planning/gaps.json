[
  {
    "question": "Should we use `?` (Rust-style), `!` (Swift-style), or `try` (keyword) for error propagation syntax?",
    "rationale": "This is a critical syntax decision that affects all future code. The `?` operator is proven in Rust with 8+ years of real-world use and is concise and unambiguous. However, Swift uses `try!` and some users might prefer a keyword. This decision blocks implementation start."
  },
  {
    "question": "When returning from an error propagation, should we use zero values (safe for all types but verbose) or nil (only works for pointers)?",
    "rationale": "For `return` statements generated by `?`, we need to decide the return value strategy. Example: `return User{}, err` vs `return nil, err`. Zero values work universally but can be verbose. Nil only works for pointer types. This affects generated code quality and type safety."
  },
  {
    "question": "Should we handle nested expressions with `?` in the MVP (like `g(f()?)`) or only support statement-level usage initially?",
    "rationale": "Nested expressions add significant complexity to the transformation logic. We could start with simple cases (assignment only) and add nested support later, or tackle it upfront. This affects timeline (2 weeks simple vs 3 weeks full) and user expectations."
  },
  {
    "question": "Do you want source maps in this phase, or should we defer them to Phase 2?",
    "rationale": "Source maps enable error messages to point to .dingo files instead of generated .go files. This improves developer experience significantly but adds 1-2 weeks to the timeline. We could ship Phase 1.5 without source maps and add them in Phase 2, or include them now for better UX."
  },
  {
    "question": "Should we implement a simplified type validator now, or rely entirely on Go's compiler to catch type errors?",
    "rationale": "We can build a basic type checker that validates `?` is used on function calls returning (T, error), or we can skip this and let Go's compiler catch errors. The validator provides better error messages (pointing to .dingo source) but adds 3-4 days of work. Without it, users see Go compiler errors pointing to generated code."
  },
  {
    "question": "What level of Go interoperability testing do you want? Should we test with real stdlib packages (http, database/sql, os) or synthetic examples?",
    "rationale": "Testing with real Go standard library packages (like http.Get, sql.Query, os.ReadFile) validates our approach works in production scenarios. However, it requires more complex test setup. Synthetic examples are faster to test but don't prove real-world viability. This affects confidence level in the implementation."
  },
  {
    "question": "Do you want to proceed with Error Propagation first, or would you prefer to start with Result types (3-4 weeks) for a more complete solution?",
    "rationale": "The plan recommends Error Propagation as the simplest P0 feature to validate the architecture (2-3 weeks). However, if you prefer a more complete error handling story upfront, we could start with Result<T,E> types instead (3-4 weeks, requires sum types foundation). This is a strategic timeline vs completeness tradeoff."
  }
]
