# Code Generation Corruption Investigation

## Problem Statement

The Dingo transpiler's `pattern_match_01_simple` test generates severely corrupted Go code where type declarations are intermingled with match marker comments in wrong positions.

## Context

**Test File**: `tests/golden/pattern_match_01_simple.dingo`
**Issue**: Generated Go code has type declarations mixed with match comments
**Impact**: Code is unusable, cannot compile
**Status**: 12/13 other pattern match tests work correctly (92% success)

## Symptoms

**Expected Output** (Clean, working code):
```go
package main

import "fmt"

// Example 1: Pattern match on Result<T,E>
func processResult(result Result_int_error) int {
    __match_0 := result
    switch __match_0.tag {
    case ResultTagOk:
        value := *__match_0.ok_0
        value * 2
    case ResultTagErr:
        e := __match_0.err_0
        0
    }
}
```

**Actual Output** (Corrupted):
```go
package main

type OptionTag uint8

const (
    OptionTag_Some OptionTag = iota
    OptionTag_None
)

type Option_string struct

// Example 1: Pattern match on Result[T,E]  ← WRONG LOCATION
{
    tag    OptionTag
    some_0 *string
}

func Option_string_Some(arg0 string) Option_string {
    return Option_string{

    // DINGO_MATCH_START: result  ← WRONG LOCATION
    tag: OptionTag_Some, some_0: &arg0}
}
```

## Recent Changes

### Fix Attempt (Made Things Worse)
Modified `pkg/preprocessor/rust_match.go` to detect assignment context:

1. Added `isInAssignmentContext()` method
2. Modified `transformMatch()` to pass assignment flag
3. Modified `generateSwitch()` to skip temp variable when `isInAssignment = true`

**Result**: Generated code now has comments and type declarations in completely wrong locations.

### Previous Working State
- Before fix: `var result = __match_3 := opt` (syntax error but structure intact)
- After fix: Type declarations intermingled with comments (structure destroyed)

## Root Cause Hypothesis

**Possible Issues:**
1. **Comment/marker positioning**: DINGO_MATCH comments being inserted at wrong line positions
2. **Preprocessor output corruption**: Text replacement happening in wrong order
3. **Buffer/string manipulation**: Characters being inserted at wrong offsets
4. **Multiple pass interaction**: One preprocessor corrupting another's output

## Code Context

### RustMatchProcessor (`pkg/preprocessor/rust_match.go`)

**Relevant Functions:**
- `Process(dingoCode string)` - Main entry point
- `transformMatch()` - Identifies and transforms match expressions
- `generateSwitch()` - Generates switch statement with markers
- `isInAssignmentContext()` - NEW: Detects assignment context

**Marker Generation:**
```go
// generateSwitch() adds these markers:
matchStart := fmt.Sprintf("// DINGO_MATCH_START: %s\n", scrutinee)
```

### Pipeline Order
```
1. GenericSyntaxProcessor  (<> → [])
2. TypeAnnotProcessor      (: → space)
3. ErrorPropProcessor      (expr? → error handling)
4. EnumProcessor           (enum → structs)
5. RustMatchProcessor      (match → switch)  ← PROBLEM HERE
6. KeywordProcessor        (let → var)
```

## Questions for Investigation

### Q1: Marker Insertion Position
**Question**: Are DINGO_MATCH markers being inserted at correct byte offsets in the string?

**Check**:
- Does `generateSwitch()` calculate position correctly?
- Are markers inserted relative to match expression or absolute position?
- Could earlier preprocessors shift positions?

### Q2: Preprocessor Interaction
**Question**: Is RustMatchProcessor output being corrupted by later processors?

**Check**:
- Does KeywordProcessor (runs after) affect marker positions?
- Are enum type declarations generated by EnumProcessor (runs before) being moved?
- Could ErrorPropProcessor be interfering?

### Q3: String Building Logic
**Question**: Is the string concatenation/replacement logic sound?

**Check**:
- Review how `generateSwitch()` builds output string
- Look for off-by-one errors in position calculations
- Check if multiple replacements overlap

### Q4: Assignment Context Detection
**Question**: Is `isInAssignmentContext()` causing side effects?

**Check**:
- Does this function modify state?
- Could detection logic trigger different code paths that corrupt output?
- Is the assignment context flag used correctly?

## Debugging Approach Needed

**Phase 1: Isolate**
1. Create minimal reproduction (single match expression)
2. Run ONLY RustMatchProcessor (skip others)
3. Verify markers appear in correct positions

**Phase 2: Identify**
1. Add debug logging for marker insertion positions
2. Compare input/output byte positions
3. Identify where corruption starts

**Phase 3: Fix**
1. Correct position calculation
2. Ensure markers inserted relative to correct anchors
3. Verify preprocessor order isn't causing issues

## Expected Deliverables

Please provide:

1. **Root Cause Analysis**
   - What is causing the corruption?
   - Which code path or function is responsible?
   - Why did the assignment context fix make it worse?

2. **Concrete Fix**
   - Specific code changes needed
   - Where to apply fixes (file:line)
   - How to prevent regression

3. **Testing Strategy**
   - How to verify fix works
   - How to test without breaking other tests
   - Minimal reproduction case

4. **Risk Assessment**
   - What could go wrong with proposed fix?
   - Will it affect other 12 working tests?
   - Performance impact?

## Files to Review

**Primary**:
- `pkg/preprocessor/rust_match.go` (lines 147-428) - transformMatch, generateSwitch, isInAssignmentContext
- `tests/golden/pattern_match_01_simple.dingo` - Test input
- `tests/golden/pattern_match_01_simple.go.golden` - Expected output

**Supporting**:
- `pkg/preprocessor/preprocessor.go` - Pipeline order
- `pkg/preprocessor/keyword.go` - KeywordProcessor (runs after)
- `pkg/plugin/builtin/pattern_match.go` - AST transformation (might help understand markers)

## Constraints

- Must not break 12 working tests
- Must maintain preprocessor pipeline architecture
- Must handle both assignment and non-assignment contexts
- Performance: <20ms compile overhead

## Success Criteria

✅ `pattern_match_01_simple` generates clean Go code
✅ Type declarations appear before functions (not intermingled)
✅ Match markers in correct positions
✅ All 13/13 tests compile successfully
