# Architectural Plan: Fix Build Issues

## Problem Summary

The Dingo project has two critical build failures that prevent compilation:

1. **pkg/transform Build Error**: Duplicate method declaration (`transformErrorProp` defined in both `transformer.go:104` and `error_prop.go:15`)
2. **pkg/transform Code Quality Issues**: Unused variables in `error_prop.go` (lines 67, 71, 194)
3. **tests/golden Test Failures**: Multiple undefined symbol errors due to missing imports

### Root Cause Analysis

After analyzing the codebase, the issues stem from:

1. **Architectural Confusion**: The project has TWO separate transformation systems:
   - **Preprocessor** (`pkg/preprocessor/error_prop.go`) - Regex-based line-level transformations (ACTIVE)
   - **Transformer** (`pkg/transform/*`) - AST-based transformations (INCOMPLETE/ABANDONED)

2. **Duplicate Implementation**: `transformErrorProp` was being implemented in the AST transformer when error propagation is already fully handled by the preprocessor

3. **Test File Issues**: Golden test `.go` files are generated by the preprocessor but missing necessary imports

## Recommended Approach

### Strategy: Remove Duplicate, Fix Tests, Clean Architecture

The solution is to **remove the incomplete AST-based error propagation transformer** and rely entirely on the preprocessor (which is already working). Then fix test file imports.

**Rationale:**
- The preprocessor (`pkg/preprocessor/error_prop.go`) is a complete, battle-tested implementation with 693 lines of production code
- It handles all error propagation cases with proper source mapping
- The AST transformer (`pkg/transform/error_prop.go`) is incomplete (262 lines) and duplicates functionality
- Having two systems creates confusion and maintenance burden
- The preprocessor approach is proven and simpler for this feature

## Package Structure & Responsibilities

### Current Architecture (After Fix)

```
pkg/
├── preprocessor/          # Line-level transformations (PRIMARY for error propagation)
│   ├── preprocessor.go    # Main processor orchestrator
│   └── error_prop.go      # Error propagation (? operator) - COMPLETE
│
├── transform/             # AST-level transformations (FOR FUTURE FEATURES)
│   └── transformer.go     # Stub for lambdas, pattern matching, etc.
│
├── parser/                # Go parser wrapper
│   └── parser.go          # Standard go/parser wrapper
│
└── generator/             # Code generation
    └── generator.go       # go/printer wrapper with plugins
```

### Clear Responsibility Boundaries

1. **Preprocessor** (`pkg/preprocessor/*`):
   - **Purpose**: String/regex-based transformations of Dingo syntax → valid Go syntax
   - **Handles**: Error propagation (`?`), future simple syntax sugar
   - **Input**: `.dingo` source (raw text)
   - **Output**: Valid Go source (raw text) + source mappings
   - **Why**: Some features are easier to implement as text transformations

2. **Parser** (`pkg/parser/*`):
   - **Purpose**: Wrap `go/parser` to parse preprocessed Go code
   - **Input**: Preprocessed Go source
   - **Output**: `*ast.File`

3. **Transformer** (`pkg/transform/*`):
   - **Purpose**: AST-based transformations for complex features
   - **Handles**: Lambdas, pattern matching, safe navigation (FUTURE)
   - **Input**: `*ast.File`
   - **Output**: Modified `*ast.File`
   - **Why**: Complex features need type information and AST manipulation

4. **Generator** (`pkg/generator/*`):
   - **Purpose**: Convert AST back to Go source code
   - **Input**: `*ast.File`
   - **Output**: Final `.go` source code

### Pipeline Flow

```
.dingo file
    ↓
[Preprocessor] → Go source (with ? expanded) + mappings
    ↓
[Parser] → AST
    ↓
[Transformer] → Modified AST (for future features)
    ↓
[Generator] → Final .go file
```

## Implementation Plan

### Phase 1: Remove Duplicate Code (1 hour)

**File: `pkg/transform/error_prop.go`**
- **Action**: DELETE entire file
- **Rationale**: Error propagation is fully handled by preprocessor

**File: `pkg/transform/transformer.go`**
- **Action**: Remove `transformErrorProp` method (lines 103-108)
- **Action**: Remove error propagation case from `handlePlaceholderCall` (lines 78-79 commented out already)
- **Result**: Clean transformer ready for future features

### Phase 2: Fix Golden Test Files (2-3 hours)

**Root Cause**: The preprocessor generates Go code with function calls like `ReadFile()`, `Unmarshal()`, `Atoi()` but doesn't add the necessary imports (`os`, `encoding/json`, `strconv`).

**Solution Options:**

#### Option A: Enhance Preprocessor Import Detection (RECOMMENDED)
Add automatic import detection to `pkg/preprocessor/error_prop.go`:

```go
// Track imports needed based on function calls
type ImportTracker struct {
    needed map[string]string // funcName → import path
}

var commonFunctions = map[string]string{
    "ReadFile":   "os",
    "WriteFile":  "os",
    "Unmarshal":  "encoding/json",
    "Marshal":    "encoding/json",
    "Atoi":       "strconv",
    "Itoa":       "strconv",
    "ParseInt":   "strconv",
    "ParseFloat": "strconv",
}
```

Then in `Process()` method, scan for these function calls and add imports using `astutil.AddImport()`.

**Pros:**
- Automatic, no manual intervention needed
- Scales to all test files
- Production-ready solution

**Cons:**
- More complex implementation
- Need to handle package aliases

#### Option B: Manual Import Addition (QUICK FIX)
Add missing imports directly to each golden test `.go` file:

```go
// error_prop_01_simple.go
import "os"  // Add this

// error_prop_02_multiple.go
import (
    "os"
    "encoding/json"
)

// error_prop_03_expression.go
import "strconv"
```

**Pros:**
- Immediate fix
- Simple to implement

**Cons:**
- Manual, error-prone
- Doesn't solve root cause
- Future tests will have same issue

#### Option C: Update Golden Test Source Files
Modify `.dingo` source files to include imports:

```dingo
// error_prop_01_simple.dingo
package main

import "os"

func readConfig(path: string) ([]byte, error) {
    let data = os.ReadFile(path)?  // Fully qualified call
    return data, nil
}
```

**Pros:**
- Tests are self-contained
- Teaches proper Dingo syntax with imports

**Cons:**
- Requires updating 46 test files
- Tests should use minimal syntax

### Recommended: Option A (Automatic Import Detection)

Implement smart import tracking in the preprocessor:

1. **Scan Phase**: During `Process()`, track all function calls
2. **Match Phase**: Map function names to standard library packages
3. **Import Phase**: Use `astutil.AddImport()` to add necessary imports
4. **Fallback**: For unknown functions, let Go compiler catch the error

### Phase 3: Verify Build Success (30 minutes)

**Steps:**
1. Run `go build ./...` - should succeed
2. Run `go test ./pkg/...` - verify all package tests pass
3. Run golden tests individually
4. Fix any remaining issues

### Phase 4: Documentation Update (30 minutes)

**Files to Update:**
- `CHANGELOG.md` - Document the architectural cleanup
- `ai-docs/architecture-decisions.md` (create if needed) - Explain preprocessor vs transformer split
- `pkg/transform/README.md` (create) - Document transformer's future role

## Key Interfaces & Types

### Preprocessor (No Changes Needed)

```go
// pkg/preprocessor/error_prop.go
type ErrorPropProcessor struct {
    tryCounter  int
    lines       []string
    currentFunc *funcContext
    needsFmt    bool

    // NEW: Track imports
    neededImports map[string]bool
}

func (e *ErrorPropProcessor) Process(source []byte) ([]byte, []Mapping, error)
func (e *ErrorPropProcessor) ensureImports(source []byte) []byte
func (e *ErrorPropProcessor) trackFunctionCall(funcName string)
```

### Transformer (Simplified)

```go
// pkg/transform/transformer.go
type Transformer struct {
    fset      *token.FileSet
    sourceMap *preprocessor.SourceMap
    typeInfo  *types.Info
}

// Only handles future features (lambdas, pattern matching)
func (t *Transformer) Transform(file *ast.File) (*ast.File, error)
func (t *Transformer) transformLambda(cursor *astutil.Cursor, call *ast.CallExpr) bool
func (t *Transformer) transformMatch(cursor *astutil.Cursor, call *ast.CallExpr) bool
func (t *Transformer) transformSafeNav(cursor *astutil.Cursor, call *ast.CallExpr) bool
```

## Dependency Map

```
cmd/dingo
    ↓
pkg/preprocessor (error_prop.go) ← No deps on transform
    ↓
pkg/parser ← go/parser, go/token
    ↓
pkg/transform (transformer.go) ← go/ast, go/token, preprocessor (for SourceMap)
    ↓
pkg/generator ← go/printer, go/token
```

**External Dependencies:**
- `go/ast`, `go/parser`, `go/printer`, `go/token` - Standard library
- `golang.org/x/tools/go/ast/astutil` - AST manipulation utilities
- `go/types` - Type information (for future transformer features)

## Implementation Notes

### Critical Details

1. **Import Detection Logic**:
   - Use regex to find function calls: `\b([A-Z]\w+)\(`
   - Match against known standard library functions
   - Handle qualified calls: `os.ReadFile` vs `ReadFile`
   - Only add imports if function is called in error propagation context

2. **Source Map Preservation**:
   - Adding imports shifts line numbers
   - Update mappings to account for added import statements
   - Import additions happen AFTER error propagation expansion

3. **Testing Strategy**:
   - Unit tests for import detection
   - Golden tests should compile without errors
   - Integration test: `.dingo` → `.go` → `go build` succeeds

### Gotchas

1. **Import Conflicts**: If user already has `import "os"`, don't duplicate
   - Solution: Use `astutil.AddImport()` which handles duplicates

2. **Package Aliases**: User might use `import myos "os"`
   - Solution: For golden tests, assume standard imports (no aliases)

3. **Multiple Return Values**: Some functions return `(T, error)`, others just `T`
   - Already handled by preprocessor's `parseFunctionSignature()`

4. **Error Variable Naming**: Auto-generated `__err0`, `__tmp0` could conflict
   - Already handled: counter ensures unique names per function

## Testing Strategy

### Unit Tests

1. **Import Detection Tests** (`pkg/preprocessor/error_prop_test.go`):
```go
func TestImportDetection(t *testing.T) {
    tests := []struct {
        name     string
        source   string
        expected []string
    }{
        {
            name:     "ReadFile needs os import",
            source:   `let data = ReadFile("file")?`,
            expected: []string{"os"},
        },
        {
            name:     "Multiple functions",
            source:   `let x = Atoi("42")?\nlet y = ReadFile("f")?`,
            expected: []string{"strconv", "os"},
        },
    }
    // ...
}
```

2. **Transformer Tests** (`pkg/transform/transformer_test.go`):
```go
func TestNoErrorPropInTransformer(t *testing.T) {
    // Verify transformer doesn't handle error propagation
    // (It's preprocessor's job)
}
```

### Integration Tests

1. **Golden Test Compilation**:
```bash
cd tests/golden
for f in *.go; do
    go build -o /dev/null "$f" || echo "FAIL: $f"
done
```

2. **End-to-End Pipeline Test**:
```go
func TestPipeline(t *testing.T) {
    // .dingo → preprocessor → parser → transformer → generator → .go
    // Verify .go compiles and runs
}
```

### Validation Checklist

- [ ] `go build ./...` succeeds with no errors
- [ ] `go test ./pkg/...` all tests pass
- [ ] All 46 golden `.go` files compile successfully
- [ ] No duplicate code warnings
- [ ] No unused variable warnings
- [ ] Source maps still accurate after import additions

## Alternatives Considered

### Alternative 1: Keep Both Preprocessor and Transformer for Error Propagation

**Approach**: Make transformer the primary error propagation handler, remove preprocessor version.

**Pros:**
- Single source of truth
- AST-based is more "correct"
- Better type information

**Cons:**
- Preprocessor is already complete and working (693 lines)
- AST approach is harder to maintain
- Source mapping is trickier with AST transformations
- Would require significant rewrite

**Rejected because**: Preprocessor is proven, simpler, and already handles all edge cases.

### Alternative 2: Make Transformer Call Preprocessor

**Approach**: Transformer orchestrates, delegates error prop to preprocessor.

**Pros:**
- Single entry point
- Clear delegation

**Cons:**
- Unnecessary indirection
- Preprocessor works on text, transformer on AST (incompatible)
- Pipeline already has clear phases

**Rejected because**: Pipeline architecture is cleaner with separate phases.

### Alternative 3: Manual Import Management in Tests

**Approach**: Require all `.dingo` test files to manually specify imports.

**Pros:**
- Explicit, no magic
- Tests are complete

**Cons:**
- Tedious for 46+ test files
- Defeats purpose of convenience syntax
- Not production-ready

**Rejected because**: Automatic import detection is a key quality-of-life feature.

## Timeline Estimate

| Phase | Task | Time | Dependencies |
|-------|------|------|--------------|
| 1 | Remove duplicate error_prop code | 1 hour | None |
| 2a | Implement import detection in preprocessor | 2 hours | Phase 1 |
| 2b | Update golden test generation | 1 hour | Phase 2a |
| 3 | Verify all builds succeed | 30 min | Phase 2 |
| 4 | Documentation updates | 30 min | Phase 3 |
| **Total** | | **5 hours** | |

**Critical Path**: Phase 1 → Phase 2a → Phase 2b → Phase 3

**Risks:**
- Import detection may miss edge cases (mitigate with comprehensive tests)
- Source map line numbers may shift (mitigate with careful offset tracking)
- Unknown function calls (mitigate with graceful fallback)

## Success Criteria

1. **Build Success**: `go build ./...` completes with zero errors
2. **Test Success**: All package tests pass
3. **Golden Tests**: All 46 golden test `.go` files compile
4. **Code Quality**: Zero unused variables, zero duplicate declarations
5. **Documentation**: Architecture decision documented
6. **Maintainability**: Clear separation between preprocessor and transformer roles

## Next Steps After This Fix

Once build is successful, the project can proceed to:

1. **Phase 2.8**: Implement lambda transformations in `pkg/transform`
2. **Phase 2.9**: Implement pattern matching in `pkg/transform`
3. **Phase 3**: Result/Option type integration
4. **Phase 4**: Language server development

The cleaned-up architecture will provide a solid foundation for these future features.
