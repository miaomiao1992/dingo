// Package builtin provides placeholder resolution plugin
package builtin

import (
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"strings"

	"github.com/MadAppGang/dingo/pkg/plugin"
	"golang.org/x/tools/go/ast/astutil"
)

// PlaceholderResolverPlugin resolves ALL machine directive placeholders
// generated by preprocessors: __INFER__, __UNWRAP__, __IS_SOME__, __SAFE_NAV_INFER__
//
// This is a CRITICAL production fix to ensure generated Go code is human-readable
// and contains no machine-like directives, following Dingo's core principle.
//
// Placeholders resolved:
// - __INFER__ → Concrete types (string, int, Option_T, etc.)
// - __UNWRAP__(expr) → Proper unwrap code for Option types
// - __IS_SOME__(expr) → expr.IsSome() method calls
// - __SAFE_NAV_INFER__ → Concrete pointer types
// - __INFER___None() → Option_T_None()
// - __INFER___Some(val) → Option_T_Some(val)
type PlaceholderResolverPlugin struct {
	ctx           *plugin.Context
	typeInference *TypeInferenceService
	errors        []string

	// Track replacements for debugging
	replacements map[string]int
}

// NewPlaceholderResolverPlugin creates a new placeholder resolver
func NewPlaceholderResolverPlugin() *PlaceholderResolverPlugin {
	return &PlaceholderResolverPlugin{
		errors:       make([]string, 0),
		replacements: make(map[string]int),
	}
}

// Name returns the plugin name
func (p *PlaceholderResolverPlugin) Name() string {
	return "placeholder_resolver"
}

// SetContext sets the plugin context
func (p *PlaceholderResolverPlugin) SetContext(ctx *plugin.Context) {
	p.ctx = ctx

	// Initialize type inference service
	if ctx != nil && ctx.FileSet != nil {
		service, err := NewTypeInferenceService(ctx.FileSet, nil, ctx.Logger)
		if err != nil {
			ctx.Logger.Warn("PlaceholderResolver: Failed to create type inference service: %v", err)
			return
		}

		p.typeInference = service

		// Inject go/types.Info if available
		if ctx.TypeInfo != nil {
			if typesInfo, ok := ctx.TypeInfo.(*types.Info); ok {
				service.SetTypesInfo(typesInfo)
				ctx.Logger.Debug("PlaceholderResolver: go/types integration enabled")
			}
		}
	}
}

// Process discovers placeholders (Discovery Phase)
func (p *PlaceholderResolverPlugin) Process(node ast.Node) error {
	// Build parent map if needed
	if p.ctx != nil && p.ctx.GetParentMap() == nil {
		if file, ok := node.(*ast.File); ok {
			p.ctx.BuildParentMap(file)
		}
	}

	// Count placeholders for debugging
	ast.Inspect(node, func(n ast.Node) bool {
		switch node := n.(type) {
		case *ast.Ident:
			if strings.HasPrefix(node.Name, "__") && strings.HasSuffix(node.Name, "__") {
				p.replacements[node.Name] = p.replacements[node.Name] + 1
				p.ctx.Logger.Debug("PlaceholderResolver: Found placeholder %s", node.Name)
			}
		case *ast.CallExpr:
			if fun, ok := node.Fun.(*ast.Ident); ok {
				if strings.HasPrefix(fun.Name, "__") {
					p.replacements[fun.Name] = p.replacements[fun.Name] + 1
					p.ctx.Logger.Debug("PlaceholderResolver: Found placeholder call %s", fun.Name)
				}
			}
		}
		return true
	})

	return nil
}

// Transform replaces all placeholders (Transform Phase)
func (p *PlaceholderResolverPlugin) Transform(node ast.Node) (ast.Node, error) {
	if p.ctx == nil {
		return node, fmt.Errorf("plugin context not initialized")
	}

	// First pass: resolve func() __INFER__ return types
	funcLitTypes := p.resolveFuncLitReturnTypes(node)

	// Second pass: replace all placeholders
	funcLitStack := []*ast.FuncLit{}

	transformed := astutil.Apply(node,
		// Pre-order traversal
		func(cursor *astutil.Cursor) bool {
			n := cursor.Node()

			// Track function literal context
			if funcLit, ok := n.(*ast.FuncLit); ok {
				funcLitStack = append(funcLitStack, funcLit)

				// Replace func() __INFER__ return types
				if funcLit.Type != nil && funcLit.Type.Results != nil {
					if len(funcLit.Type.Results.List) == 1 {
						if ident, ok := funcLit.Type.Results.List[0].Type.(*ast.Ident); ok {
							if ident.Name == "__INFER__" {
								if optionType, ok := funcLitTypes[funcLit]; ok {
									// Create new function type with concrete return type
									newFuncType := *funcLit.Type
									newResults := &ast.FieldList{
										List: []*ast.Field{
											{Type: ast.NewIdent(optionType)},
										},
									}
									newFuncType.Results = newResults
									newFuncLit := &ast.FuncLit{
										Type: &newFuncType,
										Body: funcLit.Body,
									}
									cursor.Replace(newFuncLit)
									p.ctx.Logger.Debug("PlaceholderResolver: Replaced func() __INFER__ with func() %s", optionType)
								}
							}
						}
					}
				}
			}

			// Handle different placeholder patterns
			switch node := n.(type) {
			case *ast.CallExpr:
				p.handleCallExpr(cursor, node, funcLitStack, funcLitTypes)

			case *ast.Ident:
				p.handleIdent(cursor, node)
			}

			return true
		},
		// Post-order traversal
		func(cursor *astutil.Cursor) bool {
			if _, ok := cursor.Node().(*ast.FuncLit); ok {
				if len(funcLitStack) > 0 {
					funcLitStack = funcLitStack[:len(funcLitStack)-1]
				}
			}
			return true
		},
	)

	// Log replacement statistics
	for placeholder, count := range p.replacements {
		if count > 0 {
			p.ctx.Logger.Debug("PlaceholderResolver: Replaced %d instances of %s", count, placeholder)
		}
	}

	return transformed, nil
}

// resolveFuncLitReturnTypes resolves return types for all func() __INFER__ literals
func (p *PlaceholderResolverPlugin) resolveFuncLitReturnTypes(node ast.Node) map[*ast.FuncLit]string {
	funcLitTypes := make(map[*ast.FuncLit]string)

	ast.Inspect(node, func(n ast.Node) bool {
		if funcLit, ok := n.(*ast.FuncLit); ok {
			if funcLit.Type != nil && funcLit.Type.Results != nil {
				if len(funcLit.Type.Results.List) == 1 {
					if ident, ok := funcLit.Type.Results.List[0].Type.(*ast.Ident); ok {
						if ident.Name == "__INFER__" {
							// Analyze function body to determine return type
							returnType := p.inferReturnTypeFromBody(funcLit)
							if returnType != "" {
								funcLitTypes[funcLit] = returnType
								p.ctx.Logger.Debug("PlaceholderResolver: Inferred return type %s for IIFE", returnType)
							}
						}
					}
				}
			}
		}
		return true
	})

	return funcLitTypes
}

// inferReturnTypeFromBody analyzes function body to determine return type
func (p *PlaceholderResolverPlugin) inferReturnTypeFromBody(funcLit *ast.FuncLit) string {
	if funcLit.Body == nil {
		return ""
	}

	var returnType string
	var returnTypes []string

	// Look for return statements and infer type
	ast.Inspect(funcLit.Body, func(n ast.Node) bool {
		if ret, ok := n.(*ast.ReturnStmt); ok && len(ret.Results) > 0 {
			// Analyze first return value
			result := ret.Results[0]

			// Try to infer type from the return expression
			switch expr := result.(type) {
			case *ast.BasicLit:
				// Literal values
				switch expr.Kind {
				case token.STRING:
					returnTypes = append(returnTypes, "string")
				case token.INT:
					returnTypes = append(returnTypes, "int")
				case token.FLOAT:
					returnTypes = append(returnTypes, "float64")
				}

			case *ast.Ident:
				// Variable or constant
				if expr.Name == "nil" {
					// Could be pointer or Option
					nilType := p.inferNilReturnType(funcLit)
					if nilType != "" {
						returnTypes = append(returnTypes, nilType)
					}
				} else if expr.Name == "fallback" || strings.Contains(expr.Name, "Option") {
					// Likely an Option variable
					// Try to find its type in surrounding code
					optType := p.inferVariableType(funcLit, expr.Name)
					if optType != "" {
						returnTypes = append(returnTypes, optType)
					}
				} else {
					// Try to get type from context
					if p.typeInference != nil {
						if typ, ok := p.typeInference.InferType(expr); ok {
							typeName := p.typeInference.TypeToString(typ)
							returnTypes = append(returnTypes, typeName)
						}
					}
				}

			case *ast.CallExpr:
				// Function call - check if it's an Option constructor
				if fun, ok := expr.Fun.(*ast.Ident); ok {
					if strings.HasPrefix(fun.Name, "Option_") && strings.HasSuffix(fun.Name, "_None") {
						returnTypes = append(returnTypes, strings.TrimSuffix(fun.Name, "_None"))
					} else if strings.HasPrefix(fun.Name, "Option_") && strings.HasSuffix(fun.Name, "_Some") {
						returnTypes = append(returnTypes, strings.TrimSuffix(fun.Name, "_Some"))
					} else if strings.HasSuffix(fun.Name, "OptionNone") {
						// StringOptionNone -> StringOption
						returnTypes = append(returnTypes, strings.TrimSuffix(fun.Name, "None"))
					} else if strings.HasSuffix(fun.Name, "OptionSome") {
						// StringOptionSome -> StringOption
						returnTypes = append(returnTypes, strings.TrimSuffix(fun.Name, "Some"))
					}
				}

				// Also check selector expressions for Unwrap calls
				if sel, ok := expr.Fun.(*ast.SelectorExpr); ok {
					if sel.Sel.Name == "Unwrap" {
						// The return type is the unwrapped value type
						// Try to determine what's being unwrapped
						if ident, ok := sel.X.(*ast.Ident); ok {
							optType := p.inferVariableType(funcLit, ident.Name)
							if optType != "" && strings.HasPrefix(optType, "Option_") {
								// Extract inner type: Option_string -> string
								innerType := strings.TrimPrefix(optType, "Option_")
								returnTypes = append(returnTypes, innerType)
							} else if strings.HasSuffix(optType, "Option") {
								// StringOption -> string
								innerType := strings.TrimSuffix(optType, "Option")
								returnTypes = append(returnTypes, strings.ToLower(innerType))
							}
						}
					}
				}

			case *ast.SelectorExpr:
				// Method call like value.Unwrap()
				if p.typeInference != nil {
					if typ, ok := p.typeInference.InferType(expr); ok {
						returnTypes = append(returnTypes, p.typeInference.TypeToString(typ))
					}
				}
			}
		}
		return true
	})

	// Use the most common return type, or the first one found
	if len(returnTypes) > 0 {
		// If all returns are consistent, use that type
		// Otherwise use the first non-empty one
		returnType = returnTypes[0]

		// Check if we have Option returns and primitive returns mixed
		// In null coalescing, if we have Option and primitive, return the Option type
		hasOption := false
		hasPrimitive := false
		optionType := ""

		for _, rt := range returnTypes {
			if strings.Contains(rt, "Option") {
				hasOption = true
				if optionType == "" {
					optionType = rt
				}
			} else if rt == "string" || rt == "int" || rt == "float64" || rt == "bool" {
				hasPrimitive = true
			}
		}

		// If mixed, prefer the Option type
		if hasOption && optionType != "" {
			returnType = optionType
		}
	}

	// If we couldn't determine type, look for Option patterns
	if returnType == "" {
		returnType = p.inferOptionTypeFromPatterns(funcLit)
	}

	return returnType
}

// inferVariableType tries to find the type of a variable within a function scope
func (p *PlaceholderResolverPlugin) inferVariableType(funcLit *ast.FuncLit, varName string) string {
	// Walk up to find the variable's declaration or usage in parent scope
	if p.ctx == nil {
		return ""
	}

	var varType string

	// First check in the function body for local vars
	ast.Inspect(funcLit.Body, func(n ast.Node) bool {
		// Check for variable declarations
		if assign, ok := n.(*ast.AssignStmt); ok {
			for i, lhs := range assign.Lhs {
				if ident, ok := lhs.(*ast.Ident); ok && ident.Name == varName {
					// Found the variable, try to infer type from RHS
					if i < len(assign.Rhs) {
						rhs := assign.Rhs[i]
						// Check if it's an Option constructor
						if call, ok := rhs.(*ast.CallExpr); ok {
							if fun, ok := call.Fun.(*ast.Ident); ok {
								if strings.Contains(fun.Name, "Option") {
									// Extract the Option type
									if strings.HasSuffix(fun.Name, "Some") {
										varType = strings.TrimSuffix(fun.Name, "Some")
									} else if strings.HasSuffix(fun.Name, "None") {
										varType = strings.TrimSuffix(fun.Name, "None")
									}
									return false
								}
							}
						}
					}
				}
			}
		}
		return true
	})

	// If not found locally, look in parent scope
	if varType == "" {
		p.ctx.WalkParents(funcLit, func(parent ast.Node) bool {
			if assign, ok := parent.(*ast.AssignStmt); ok {
				for i, lhs := range assign.Lhs {
					if ident, ok := lhs.(*ast.Ident); ok && ident.Name == varName {
						if i < len(assign.Rhs) {
							rhs := assign.Rhs[i]
							if call, ok := rhs.(*ast.CallExpr); ok {
								if fun, ok := call.Fun.(*ast.Ident); ok {
									if strings.Contains(fun.Name, "Option") {
										if strings.HasSuffix(fun.Name, "Some") {
											varType = strings.TrimSuffix(fun.Name, "Some")
										} else if strings.HasSuffix(fun.Name, "None") {
											varType = strings.TrimSuffix(fun.Name, "None")
										}
										return false
									}
								}
							}
						}
					}
				}
			}
			return true
		})
	}

	return varType
}

// inferNilReturnType tries to determine type when nil is returned
func (p *PlaceholderResolverPlugin) inferNilReturnType(funcLit *ast.FuncLit) string {
	// Look for other returns or Option patterns in the function
	var optionType string

	ast.Inspect(funcLit.Body, func(n ast.Node) bool {
		if call, ok := n.(*ast.CallExpr); ok {
			if fun, ok := call.Fun.(*ast.Ident); ok {
				// Look for Option_T_None or Option_T_Some patterns
				if strings.HasPrefix(fun.Name, "Option_") {
					if strings.HasSuffix(fun.Name, "_None") {
						optionType = strings.TrimSuffix(fun.Name, "_None")
						return false
					} else if strings.HasSuffix(fun.Name, "_Some") {
						optionType = strings.TrimSuffix(fun.Name, "_Some")
						return false
					}
				}
			}
		}
		return true
	})

	return optionType
}

// inferOptionTypeFromPatterns looks for Option type patterns in function body
func (p *PlaceholderResolverPlugin) inferOptionTypeFromPatterns(funcLit *ast.FuncLit) string {
	var optionType string

	ast.Inspect(funcLit.Body, func(n ast.Node) bool {
		// Look for .IsSome(), .IsNone(), .Unwrap() calls
		if call, ok := n.(*ast.CallExpr); ok {
			if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
				methodName := sel.Sel.Name
				if methodName == "IsSome" || methodName == "IsNone" || methodName == "Unwrap" {
					// Get the type of the receiver
					if p.typeInference != nil {
						if typ, ok := p.typeInference.InferType(sel.X); ok {
							typeName := p.typeInference.TypeToString(typ)
							if strings.HasPrefix(typeName, "Option_") {
								optionType = typeName
								return false
							}
						}
					}
				}
			}
		}

		// Look for Option_T_None/Some constructor calls
		if call, ok := n.(*ast.CallExpr); ok {
			if fun, ok := call.Fun.(*ast.Ident); ok {
				if strings.HasPrefix(fun.Name, "Option_") && !strings.Contains(fun.Name, "__INFER__") {
					if strings.HasSuffix(fun.Name, "_None") {
						optionType = strings.TrimSuffix(fun.Name, "_None")
						return false
					} else if strings.HasSuffix(fun.Name, "_Some") {
						optionType = strings.TrimSuffix(fun.Name, "_Some")
						return false
					}
				}
			}
		}

		return true
	})

	return optionType
}

// handleCallExpr handles placeholder function calls
func (p *PlaceholderResolverPlugin) handleCallExpr(cursor *astutil.Cursor, call *ast.CallExpr, funcLitStack []*ast.FuncLit, funcLitTypes map[*ast.FuncLit]string) {
	fun, ok := call.Fun.(*ast.Ident)
	if !ok {
		return
	}

	switch fun.Name {
	case "__UNWRAP__":
		p.replaceUnwrap(cursor, call)

	case "__IS_SOME__":
		p.replaceIsSome(cursor, call)

	case "__INFER___None", "__INFER___Some":
		p.replaceInferConstructor(cursor, call, fun.Name, funcLitStack, funcLitTypes)

	case "__SAFE_NAV_INFER__":
		p.replaceSafeNavInfer(cursor, call)
	}
}

// replaceUnwrap replaces __UNWRAP__(expr) with proper unwrap code
func (p *PlaceholderResolverPlugin) replaceUnwrap(cursor *astutil.Cursor, call *ast.CallExpr) {
	if len(call.Args) != 1 {
		return
	}

	arg := call.Args[0]

	// Check if the argument itself is an identifier with Option_ prefix
	// This is a simple heuristic that works for most cases
	isOption := false

	if ident, ok := arg.(*ast.Ident); ok {
		// Check if the identifier name suggests it's an Option type
		if p.typeInference != nil {
			if typ, ok := p.typeInference.InferType(ident); ok {
				typeName := p.typeInference.TypeToString(typ)
				isOption = strings.HasPrefix(typeName, "Option_")
			}
		}

		// Fallback: check if variable name contains "opt" or "Option"
		if !isOption {
			name := ident.Name
			isOption = strings.Contains(name, "opt") || strings.Contains(name, "Opt") ||
			          strings.Contains(name, "option") || strings.Contains(name, "Option")
		}
	}

	// Also check selector expressions like obj.field
	if sel, ok := arg.(*ast.SelectorExpr); ok {
		if p.typeInference != nil {
			if typ, ok := p.typeInference.InferType(sel); ok {
				typeName := p.typeInference.TypeToString(typ)
				isOption = strings.HasPrefix(typeName, "Option_")
			}
		}
	}

	if isOption {
		// Replace with expr.Unwrap()
		unwrapCall := &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   arg,
				Sel: ast.NewIdent("Unwrap"),
			},
			Args: []ast.Expr{},
		}
		cursor.Replace(unwrapCall)
		p.ctx.Logger.Debug("PlaceholderResolver: Replaced __UNWRAP__ with .Unwrap() call")
	} else {
		// For now, default to Unwrap() for safety
		// The Option type will handle the proper unwrapping
		unwrapCall := &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   arg,
				Sel: ast.NewIdent("Unwrap"),
			},
			Args: []ast.Expr{},
		}
		cursor.Replace(unwrapCall)
		p.ctx.Logger.Debug("PlaceholderResolver: Replaced __UNWRAP__ with .Unwrap() call (default)")
	}
}

// replaceIsSome replaces __IS_SOME__(expr) with expr.IsSome()
func (p *PlaceholderResolverPlugin) replaceIsSome(cursor *astutil.Cursor, call *ast.CallExpr) {
	if len(call.Args) != 1 {
		return
	}

	arg := call.Args[0]

	// Replace with expr.IsSome()
	isSomeCall := &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   arg,
			Sel: ast.NewIdent("IsSome"),
		},
		Args: []ast.Expr{},
	}
	cursor.Replace(isSomeCall)
	p.ctx.Logger.Debug("PlaceholderResolver: Replaced __IS_SOME__ with .IsSome() call")
}

// replaceInferConstructor replaces __INFER___None() and __INFER___Some()
func (p *PlaceholderResolverPlugin) replaceInferConstructor(cursor *astutil.Cursor, call *ast.CallExpr, funName string, funcLitStack []*ast.FuncLit, funcLitTypes map[*ast.FuncLit]string) {
	// Determine Option type from context
	var optionType string

	// Try to get from enclosing function literal
	if len(funcLitStack) > 0 {
		currentFuncLit := funcLitStack[len(funcLitStack)-1]
		optionType = funcLitTypes[currentFuncLit]
	}

	// If not found, try to infer from context
	if optionType == "" {
		optionType = p.inferOptionTypeFromContext(call)
	}

	if optionType != "" {
		// Replace __INFER___None with Option_T_None
		newFunName := strings.Replace(funName, "__INFER__", optionType, 1)
		newCall := &ast.CallExpr{
			Fun:  ast.NewIdent(newFunName),
			Args: call.Args,
		}
		cursor.Replace(newCall)
		p.ctx.Logger.Debug("PlaceholderResolver: Replaced %s with %s", funName, newFunName)
	}
}

// replaceSafeNavInfer replaces __SAFE_NAV_INFER__ calls
func (p *PlaceholderResolverPlugin) replaceSafeNavInfer(cursor *astutil.Cursor, call *ast.CallExpr) {
	// This is typically used in safe navigation chains
	// The pattern is: __SAFE_NAV_INFER__(expr, "field1", "field2", ...)
	// We need to determine the type and replace appropriately

	if len(call.Args) < 1 {
		return
	}

	// For now, just replace with the first argument
	// A more sophisticated implementation would trace the field access chain
	cursor.Replace(call.Args[0])
	p.ctx.Logger.Debug("PlaceholderResolver: Simplified __SAFE_NAV_INFER__ call")
}

// handleIdent handles standalone __INFER__ identifiers
func (p *PlaceholderResolverPlugin) handleIdent(cursor *astutil.Cursor, ident *ast.Ident) {
	if ident.Name == "__INFER__" {
		// Try to determine the type from context
		inferredType := p.inferTypeFromContext(ident)
		if inferredType != "" {
			cursor.Replace(ast.NewIdent(inferredType))
			p.ctx.Logger.Debug("PlaceholderResolver: Replaced __INFER__ with %s", inferredType)
		}
	}
}

// inferTypeFromContext attempts to determine type from surrounding context
func (p *PlaceholderResolverPlugin) inferTypeFromContext(node ast.Node) string {
	if p.ctx == nil {
		return ""
	}

	// Walk up the parent chain to find type hints
	var inferredType string

	p.ctx.WalkParents(node, func(parent ast.Node) bool {
		switch parentNode := parent.(type) {
		case *ast.Field:
			// Field in a struct or function signature
			if parentNode.Type != nil {
				if ident, ok := parentNode.Type.(*ast.Ident); ok && ident.Name == "__INFER__" {
					// This is what we're trying to resolve
					return true
				}
			}

		case *ast.AssignStmt:
			// Assignment statement might give us type info
			for i, rhs := range parentNode.Rhs {
				if i < len(parentNode.Lhs) {
					if p.typeInference != nil {
						if typ, ok := p.typeInference.InferType(rhs); ok {
							inferredType = p.typeInference.TypeToString(typ)
							return false
						}
					}
				}
			}
		}
		return true
	})

	return inferredType
}

// inferOptionTypeFromContext looks for Option type hints in surrounding code
func (p *PlaceholderResolverPlugin) inferOptionTypeFromContext(call *ast.CallExpr) string {
	if p.ctx == nil {
		return ""
	}

	var optionType string

	// Walk up to find the enclosing function
	p.ctx.WalkParents(call, func(parent ast.Node) bool {
		if funcLit, ok := parent.(*ast.FuncLit); ok {
			// Scan function body for Option type patterns
			ast.Inspect(funcLit.Body, func(n ast.Node) bool {
				if otherCall, ok := n.(*ast.CallExpr); ok {
					if fun, ok := otherCall.Fun.(*ast.Ident); ok {
						name := fun.Name
						if strings.HasPrefix(name, "Option_") && !strings.Contains(name, "__INFER__") {
							if strings.HasSuffix(name, "_None") {
								optionType = strings.TrimSuffix(name, "_None")
								return false
							} else if strings.HasSuffix(name, "_Some") {
								optionType = strings.TrimSuffix(name, "_Some")
								return false
							}
						}
					}
				}
				return true
			})
			return false
		}
		return true
	})

	return optionType
}