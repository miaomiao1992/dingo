package preprocessor

import (
	"bytes"
	"regexp"
	"strings"
)

// Package-level compiled regexes for lambda transformations
var (
	// TypeScript arrow syntax patterns
	// Pattern 1: Single param without parens (identifier only): x => expr
	// Match word boundary before param, capture optional prefix character
	singleParamArrow = regexp.MustCompile(`(^|[^.\w])(\w+)\s*=>\s*`)

	// Pattern 2: Params with parens (with or without types): (x) => expr, (x, y) => expr, (x: int) => expr
	// Matches: (params) => with optional return type annotation
	// Match optional prefix character (for method calls vs standalone)
	// Return type: capture everything between : and => (non-greedy)
	multiParamArrow = regexp.MustCompile(`(^|[^.\w])\(([^)]*)\)\s*(?::\s*([^=>\s]+))?\s*=>\s*`)

	// Rust pipe syntax patterns
	// Pattern 1: Single or multi param with pipes: |x| expr, |x, y| expr, |x: int| expr
	// Matches: |params| with optional return type annotation (-> Type)
	// Captures: prefix (for context), params (inside pipes), return type (after ->), body (after pipes)
	rustPipe = regexp.MustCompile(`(^|[^.\w])\|([^|]*)\|\s*(?:->\s*([^\s{]+))?\s*`)
)

// LambdaProcessor converts TypeScript arrow syntax to Go function literals
// Supports: x => expr, (x) => expr, (x, y) => expr, (x: int) => expr
type LambdaProcessor struct{}

// NewLambdaProcessor creates a new lambda processor
func NewLambdaProcessor() *LambdaProcessor {
	return &LambdaProcessor{}
}

// Name returns the processor name
func (l *LambdaProcessor) Name() string {
	return "lambda"
}

// Process transforms TypeScript arrow syntax to Go function literals
// Converts:
//   x => x * 2          →  func(x) { return x * 2 }
//   (x) => x * 2        →  func(x) { return x * 2 }
//   (x, y) => x + y     →  func(x, y) { return x + y }
//   (x: int) => x * 2   →  func(x int) int { return x * 2 }
//   (x) => { return x } →  func(x) { return x }
func (l *LambdaProcessor) Process(source []byte) ([]byte, []Mapping, error) {
	lines := bytes.Split(source, []byte("\n"))
	var result bytes.Buffer
	var mappings []Mapping

	for lineNum, line := range lines {
		originalLine := line

		// Process multi-param arrows first (they include single param with parens)
		line = l.processMultiParamArrow(line)

		// Then process single-param arrows (without parens)
		line = l.processSingleParamArrow(line)

		result.Write(line)

		// Add source mapping if line was modified
		if !bytes.Equal(originalLine, line) {
			mappings = append(mappings, Mapping{
				OriginalLine:    lineNum + 1,
				GeneratedLine:   lineNum + 1,
				OriginalColumn:  0,
				GeneratedColumn: 0,
				Length:          len(line),
			})
		}

		if lineNum < len(lines)-1 {
			result.WriteByte('\n')
		}
	}

	return result.Bytes(), mappings, nil
}

// processSingleParamArrow handles: x => expr
func (l *LambdaProcessor) processSingleParamArrow(line []byte) []byte {
	// Don't process if it's already inside a func literal
	if bytes.Contains(line, []byte("func(")) {
		return line
	}

	// Use FindAllSubmatchIndex to get submatch positions in the original string
	matches := singleParamArrow.FindAllSubmatchIndex(line, -1)
	if len(matches) == 0 {
		return line
	}

	// Build result by replacing matches from right to left (to preserve indices)
	result := line
	for i := len(matches) - 1; i >= 0; i-- {
		loc := matches[i]

		matchStart := loc[0]
		matchEnd := loc[1]

		// Extract submatches from original line
		var prefix, param []byte
		if loc[2] != -1 && loc[3] != -1 {
			prefix = line[loc[2]:loc[3]]
		}
		if loc[4] != -1 && loc[5] != -1 {
			param = line[loc[4]:loc[5]]
		}

		var buf bytes.Buffer
		// Write prefix if present
		if len(prefix) > 0 {
			buf.Write(prefix)
		}
		buf.WriteString("func(")
		buf.Write(param)
		buf.WriteString(") { return ")

		// Replace in result
		result = append(result[:matchStart], append(buf.Bytes(), result[matchEnd:]...)...)
	}

	return result
}

// processMultiParamArrow handles: (x) => expr, (x, y) => expr, (x: int) => expr, (x: int): bool => expr
func (l *LambdaProcessor) processMultiParamArrow(line []byte) []byte {
	// Don't process if it's already inside a func literal
	if bytes.Contains(line, []byte("func(")) {
		return line
	}

	// Use FindAllSubmatchIndex to get submatch positions in the original string
	matches := multiParamArrow.FindAllSubmatchIndex(line, -1)
	if len(matches) == 0 {
		return line
	}

	// Build result by replacing matches from right to left (to preserve indices)
	result := line
	for i := len(matches) - 1; i >= 0; i-- {
		loc := matches[i]
		// loc format: [matchStart, matchEnd, group1Start, group1End, group2Start, group2End, ...]

		matchStart := loc[0]
		matchEnd := loc[1]

		// Extract submatches from original line
		var prefix, params, returnType []byte
		if loc[2] != -1 && loc[3] != -1 {
			prefix = line[loc[2]:loc[3]]
		}
		if loc[4] != -1 && loc[5] != -1 {
			params = bytes.TrimSpace(line[loc[4]:loc[5]])
		}
		if len(loc) > 6 && loc[6] != -1 && loc[7] != -1 {
			returnType = bytes.TrimSpace(line[loc[6]:loc[7]])
		}

		// Parse parameters to handle type annotations
		processedParams := l.processParams(params)

		var buf bytes.Buffer
		// Write prefix if present
		if len(prefix) > 0 {
			buf.Write(prefix)
		}
		buf.WriteString("func(")
		buf.Write(processedParams)
		buf.WriteString(")")

		// Add return type if specified
		if len(returnType) > 0 {
			buf.WriteString(" ")
			buf.Write(returnType)
		}

		buf.WriteString(" { return ")

		// Replace in result
		result = append(result[:matchStart], append(buf.Bytes(), result[matchEnd:]...)...)
	}

	return result
}

// processParams handles parameter list parsing and type annotation conversion
// Handles: x, y → x, y
//          x: int → x int
//          x: int, y: string → x int, y string
func (l *LambdaProcessor) processParams(params []byte) []byte {
	if len(params) == 0 {
		return params
	}

	// Split by comma to handle multiple parameters
	paramList := bytes.Split(params, []byte(","))
	var processed [][]byte

	for _, param := range paramList {
		param = bytes.TrimSpace(param)

		// Check if parameter has type annotation (contains :)
		if bytes.Contains(param, []byte(":")) {
			// Split on : and convert to Go syntax
			parts := bytes.SplitN(param, []byte(":"), 2)
			if len(parts) == 2 {
				name := bytes.TrimSpace(parts[0])
				typeName := bytes.TrimSpace(parts[1])

				var buf bytes.Buffer
				buf.Write(name)
				buf.WriteString(" ")
				buf.Write(typeName)
				processed = append(processed, buf.Bytes())
				continue
			}
		}

		// No type annotation, keep as-is
		processed = append(processed, param)
	}

	return bytes.Join(processed, []byte(", "))
}

// postProcessLambdaBodies handles the closing brace for lambda bodies
// This is called after initial arrow replacement to properly close function literals
func (l *LambdaProcessor) postProcessLambdaBodies(source []byte) []byte {
	lines := bytes.Split(source, []byte("\n"))
	var result bytes.Buffer

	for i, line := range lines {
		// If line contains "{ return " from arrow replacement and doesn't end with }
		if bytes.Contains(line, []byte("{ return ")) && !bytes.HasSuffix(bytes.TrimSpace(line), []byte("}")) {
			// Find the end of the expression
			// Simple heuristic: if line ends with comma, semicolon, or closing paren, add }
			trimmed := bytes.TrimSpace(line)
			if bytes.HasSuffix(trimmed, []byte(",")) ||
			   bytes.HasSuffix(trimmed, []byte(")")) ||
			   bytes.Contains(trimmed, []byte("}")) {
				// Expression likely ends before these punctuation marks
				// Insert } before the final character
				line = l.insertClosingBrace(line)
			}
		}

		result.Write(line)
		if i < len(lines)-1 {
			result.WriteByte('\n')
		}
	}

	return result.Bytes()
}

// insertClosingBrace intelligently inserts } before the last significant character
func (l *LambdaProcessor) insertClosingBrace(line []byte) []byte {
	// Find the position to insert }
	// Look for trailing comma, paren, or brace
	str := string(line)

	// Find last comma, closing paren, or semicolon
	lastComma := strings.LastIndex(str, ",")
	lastParen := strings.LastIndex(str, ")")

	insertPos := -1
	if lastComma > lastParen {
		insertPos = lastComma
	} else if lastParen > lastComma {
		insertPos = lastParen
	}

	if insertPos > 0 {
		// Insert } before the punctuation
		return []byte(str[:insertPos] + " }" + str[insertPos:])
	}

	// Otherwise append } at end
	return append(bytes.TrimSpace(line), []byte(" }")...)
}
