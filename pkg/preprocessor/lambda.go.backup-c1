package preprocessor

import (
	"bytes"
	"fmt"
	"regexp"
	"strings"

	"github.com/MadAppGang/dingo/pkg/config"
	dingoerrors "github.com/MadAppGang/dingo/pkg/errors"
)

// Package-level compiled regexes for lambda transformations
var (
	// TypeScript arrow syntax patterns
	// Pattern 1: Single param without parens (identifier only): x => expr
	// Match word boundary before param, capture optional prefix character
	singleParamArrow = regexp.MustCompile(`(^|[^.\w])(\w+)\s*=>\s*`)

	// Pattern 2: Params with parens (with or without types): (x) => expr, (x, y) => expr, (x: int) => expr
	// Matches: (params) => with optional return type annotation
	// Match optional prefix character (for method calls vs standalone)
	// Return type: capture everything between : and => (non-greedy)
	multiParamArrow = regexp.MustCompile(`(^|[^.\w])\(([^)]*)\)\s*(?::\s*([^=>\s]+))?\s*=>\s*`)

	// Rust pipe syntax patterns
	// Pattern 1: Single or multi param with pipes: |x| expr, |x, y| expr, |x: int| expr
	// Matches: |params| with optional return type annotation (-> Type)
	// Captures: prefix (for context), params (inside pipes), return type (after ->), body (after pipes)
	rustPipe = regexp.MustCompile(`(^|[^.\w])\|([^|]*)\|\s*(?:->\s*([^\s{]+))?\s*`)
)

// LambdaStyle represents the lambda syntax style
type LambdaStyle int

const (
	// StyleTypeScript uses TypeScript/JavaScript arrow syntax: x => expr
	StyleTypeScript LambdaStyle = iota
	// StyleRust uses Rust pipe syntax: |x| expr
	StyleRust
)

// LambdaProcessor converts lambda syntax to Go function literals
// Supports two styles (config-driven):
// - TypeScript arrows: x => expr, (x) => expr, (x, y) => expr, (x: int) => expr
// - Rust pipes: |x| expr, |x, y| expr, |x: int| expr, |x: int| -> bool { ... }
type LambdaProcessor struct {
	style  LambdaStyle
	errors []*dingoerrors.EnhancedError
}

// NewLambdaProcessor creates a new lambda processor with default style (TypeScript)
func NewLambdaProcessor() *LambdaProcessor {
	return &LambdaProcessor{
		style: StyleTypeScript,
	}
}

// NewLambdaProcessorWithConfig creates a new lambda processor with config-driven style
func NewLambdaProcessorWithConfig(cfg *config.Config) *LambdaProcessor {
	style := StyleTypeScript // Default
	if cfg != nil && cfg.Features.LambdaStyle == "rust" {
		style = StyleRust
	}
	return &LambdaProcessor{
		style: style,
	}
}

// Name returns the processor name
func (l *LambdaProcessor) Name() string {
	return "lambda"
}

// Process transforms lambda syntax to Go function literals based on configured style
// TypeScript style:
//   x => x * 2          →  func(x) { return x * 2 }
//   (x) => x * 2        →  func(x) { return x * 2 }
//   (x, y) => x + y     →  func(x, y) { return x + y }
//   (x: int) => x * 2   →  func(x int) int { return x * 2 }
//   (x) => { return x } →  func(x) { return x }
// Rust style:
//   |x| x * 2           →  func(x) { return x * 2 }
//   |x, y| x + y        →  func(x, y) { return x + y }
//   |x: int| x * 2      →  func(x int) { return x * 2 }
//   |x: int| -> bool { x > 0 } →  func(x int) bool { return x > 0 }
func (l *LambdaProcessor) Process(source []byte) ([]byte, []Mapping, error) {
	// Reset errors for this processing run
	l.errors = nil

	lines := bytes.Split(source, []byte("\n"))
	var result bytes.Buffer
	var mappings []Mapping

	for lineNum, line := range lines {
		originalLine := line

		// Process based on configured style
		switch l.style {
		case StyleTypeScript:
			// Process multi-param arrows first (they include single param with parens)
			line = l.processMultiParamArrow(line, lineNum+1)
			// Then process single-param arrows (without parens)
			line = l.processSingleParamArrow(line, lineNum+1)

		case StyleRust:
			// Process Rust pipe syntax
			line = l.processRustPipe(line, lineNum+1)
		}

		result.Write(line)

		// Add source mapping if line was modified
		if !bytes.Equal(originalLine, line) {
			mappings = append(mappings, Mapping{
				OriginalLine:    lineNum + 1,
				GeneratedLine:   lineNum + 1,
				OriginalColumn:  0,
				GeneratedColumn: 0,
				Length:          len(line),
			})
		}

		if lineNum < len(lines)-1 {
			result.WriteByte('\n')
		}
	}

	// If we collected errors, return them
	if len(l.errors) > 0 {
		return nil, nil, l.errors[0] // Return first error for now
	}

	return result.Bytes(), mappings, nil
}

// processSingleParamArrow handles: x => expr
func (l *LambdaProcessor) processSingleParamArrow(line []byte, lineNum int) []byte {
	// Don't process if it's already inside a func literal
	if bytes.Contains(line, []byte("func(")) {
		return line
	}

	// Use FindAllSubmatchIndex to get submatch positions in the original string
	matches := singleParamArrow.FindAllSubmatchIndex(line, -1)
	if len(matches) == 0 {
		return line
	}

	// Build result by replacing matches from right to left (to preserve indices)
	result := line
	for i := len(matches) - 1; i >= 0; i-- {
		loc := matches[i]

		matchStart := loc[0]
		matchEnd := loc[1]

		// Extract submatches from original line
		var prefix, param []byte
		if loc[2] != -1 && loc[3] != -1 {
			prefix = line[loc[2]:loc[3]]
		}
		if loc[4] != -1 && loc[5] != -1 {
			param = line[loc[4]:loc[5]]
		}

		// Check for type inference failure: single param without type
		// Only error if this is truly standalone (not in a function call context)
		// Function calls have parens before the lambda: .map(x => ...)
		// Standalone: let f = x => ... OR x => ... at start of line
		isInCallContext := matchStart > 0 && line[matchStart-1] == '('

		if len(param) > 0 && !bytes.Contains(param, []byte(" ")) && !isInCallContext {
			// param is just "x" not "x int", and it's not in a call context
			// This indicates missing type information for standalone lambda
			l.addTypeInferenceError(lineNum, matchStart, string(line), string(param))
		}

		var buf bytes.Buffer
		// Write prefix if present
		if len(prefix) > 0 {
			buf.Write(prefix)
		}
		buf.WriteString("func(")
		buf.Write(param)
		buf.WriteString(") { return ")

		// Replace in result
		result = append(result[:matchStart], append(buf.Bytes(), result[matchEnd:]...)...)
	}

	return result
}

// processMultiParamArrow handles: (x) => expr, (x, y) => expr, (x: int) => expr, (x: int): bool => expr
func (l *LambdaProcessor) processMultiParamArrow(line []byte, lineNum int) []byte {
	// Don't process if it's already inside a func literal
	if bytes.Contains(line, []byte("func(")) {
		return line
	}

	// Use FindAllSubmatchIndex to get submatch positions in the original string
	matches := multiParamArrow.FindAllSubmatchIndex(line, -1)
	if len(matches) == 0 {
		return line
	}

	// Build result by replacing matches from right to left (to preserve indices)
	result := line
	for i := len(matches) - 1; i >= 0; i-- {
		loc := matches[i]
		// loc format: [matchStart, matchEnd, group1Start, group1End, group2Start, group2End, ...]

		matchStart := loc[0]
		matchEnd := loc[1]

		// Extract submatches from original line
		var prefix, params, returnType []byte
		if loc[2] != -1 && loc[3] != -1 {
			prefix = line[loc[2]:loc[3]]
		}
		if loc[4] != -1 && loc[5] != -1 {
			params = bytes.TrimSpace(line[loc[4]:loc[5]])
		}
		if len(loc) > 6 && loc[6] != -1 && loc[7] != -1 {
			returnType = bytes.TrimSpace(line[loc[6]:loc[7]])
		}

		// Check if any parameter lacks type annotation
		// Only error if this is truly standalone (not in a function call context)
		// The regex already matches prefix, so check if it's an opening paren
		isInCallContext := len(prefix) > 0 && prefix[len(prefix)-1] == '('

		if l.hasUntypedParams(params) && !isInCallContext {
			l.addTypeInferenceError(lineNum, matchStart, string(line), string(params))
		}

		// Parse parameters to handle type annotations
		processedParams := l.processParams(params)

		var buf bytes.Buffer
		// Write prefix if present
		if len(prefix) > 0 {
			buf.Write(prefix)
		}
		buf.WriteString("func(")
		buf.Write(processedParams)
		buf.WriteString(")")

		// Add return type if specified
		if len(returnType) > 0 {
			buf.WriteString(" ")
			buf.Write(returnType)
		}

		buf.WriteString(" { return ")

		// Replace in result
		result = append(result[:matchStart], append(buf.Bytes(), result[matchEnd:]...)...)
	}

	return result
}

// processRustPipe handles Rust pipe syntax: |x| expr, |x, y| expr, |x: int| -> bool { ... }
func (l *LambdaProcessor) processRustPipe(line []byte, lineNum int) []byte {
	// Don't process if it's already inside a func literal
	if bytes.Contains(line, []byte("func(")) {
		return line
	}

	// Use FindAllSubmatchIndex to get submatch positions in the original string
	matches := rustPipe.FindAllSubmatchIndex(line, -1)
	if len(matches) == 0 {
		return line
	}

	// Build result by replacing matches from right to left (to preserve indices)
	result := line
	for i := len(matches) - 1; i >= 0; i-- {
		loc := matches[i]

		matchStart := loc[0]
		matchEnd := loc[1]

		// Extract submatches from original line
		var prefix, params, returnType []byte
		if loc[2] != -1 && loc[3] != -1 {
			prefix = line[loc[2]:loc[3]]
		}
		if loc[4] != -1 && loc[5] != -1 {
			params = bytes.TrimSpace(line[loc[4]:loc[5]])
		}
		if len(loc) > 6 && loc[6] != -1 && loc[7] != -1 {
			returnType = bytes.TrimSpace(line[loc[6]:loc[7]])
		}

		// Check if any parameter lacks type annotation
		// Only error if this is truly standalone (not in a function call context)
		isInCallContext := len(prefix) > 0 && prefix[len(prefix)-1] == '('

		if l.hasUntypedParams(params) && !isInCallContext {
			l.addTypeInferenceError(lineNum, matchStart, string(line), string(params))
		}

		// Parse parameters to handle type annotations
		processedParams := l.processParams(params)

		var buf bytes.Buffer
		// Write prefix if present
		if len(prefix) > 0 {
			buf.Write(prefix)
		}
		buf.WriteString("func(")
		buf.Write(processedParams)
		buf.WriteString(")")

		// Add return type if specified
		if len(returnType) > 0 {
			buf.WriteString(" ")
			buf.Write(returnType)
		}

		// Check if body starts with { (already a block)
		// Look ahead after the match to see if there's a block
		remainingAfterMatch := line[matchEnd:]
		trimmedRemaining := bytes.TrimSpace(remainingAfterMatch)

		if bytes.HasPrefix(trimmedRemaining, []byte("{")) {
			// Body already has braces, don't add return
			buf.WriteString(" ")
		} else {
			// Expression body, needs return wrapper
			buf.WriteString(" { return ")
		}

		// Replace in result
		result = append(result[:matchStart], append(buf.Bytes(), result[matchEnd:]...)...)
	}

	return result
}

// processParams handles parameter list parsing and type annotation conversion
// Handles: x, y → x, y
//          x: int → x int
//          x: int, y: string → x int, y string
func (l *LambdaProcessor) processParams(params []byte) []byte {
	if len(params) == 0 {
		return params
	}

	// Split by comma to handle multiple parameters
	paramList := bytes.Split(params, []byte(","))
	var processed [][]byte

	for _, param := range paramList {
		param = bytes.TrimSpace(param)

		// Check if parameter has type annotation (contains :)
		if bytes.Contains(param, []byte(":")) {
			// Split on : and convert to Go syntax
			parts := bytes.SplitN(param, []byte(":"), 2)
			if len(parts) == 2 {
				name := bytes.TrimSpace(parts[0])
				typeName := bytes.TrimSpace(parts[1])

				var buf bytes.Buffer
				buf.Write(name)
				buf.WriteString(" ")
				buf.Write(typeName)
				processed = append(processed, buf.Bytes())
				continue
			}
		}

		// No type annotation, keep as-is
		processed = append(processed, param)
	}

	return bytes.Join(processed, []byte(", "))
}

// postProcessLambdaBodies handles the closing brace for lambda bodies
// This is called after initial arrow replacement to properly close function literals
func (l *LambdaProcessor) postProcessLambdaBodies(source []byte) []byte {
	lines := bytes.Split(source, []byte("\n"))
	var result bytes.Buffer

	for i, line := range lines {
		// If line contains "{ return " from arrow replacement and doesn't end with }
		if bytes.Contains(line, []byte("{ return ")) && !bytes.HasSuffix(bytes.TrimSpace(line), []byte("}")) {
			// Find the end of the expression
			// Simple heuristic: if line ends with comma, semicolon, or closing paren, add }
			trimmed := bytes.TrimSpace(line)
			if bytes.HasSuffix(trimmed, []byte(",")) ||
			   bytes.HasSuffix(trimmed, []byte(")")) ||
			   bytes.Contains(trimmed, []byte("}")) {
				// Expression likely ends before these punctuation marks
				// Insert } before the final character
				line = l.insertClosingBrace(line)
			}
		}

		result.Write(line)
		if i < len(lines)-1 {
			result.WriteByte('\n')
		}
	}

	return result.Bytes()
}

// insertClosingBrace intelligently inserts } before the last significant character
func (l *LambdaProcessor) insertClosingBrace(line []byte) []byte {
	// Find the position to insert }
	// Look for trailing comma, paren, or brace
	str := string(line)

	// Find last comma, closing paren, or semicolon
	lastComma := strings.LastIndex(str, ",")
	lastParen := strings.LastIndex(str, ")")

	insertPos := -1
	if lastComma > lastParen {
		insertPos = lastComma
	} else if lastParen > lastComma {
		insertPos = lastParen
	}

	if insertPos > 0 {
		// Insert } before the punctuation
		return []byte(str[:insertPos] + " }" + str[insertPos:])
	}

	// Otherwise append } at end
	return append(bytes.TrimSpace(line), []byte(" }")...)
}

// hasUntypedParams checks if any parameter in the list lacks a type annotation
func (l *LambdaProcessor) hasUntypedParams(params []byte) bool {
	if len(params) == 0 {
		return false
	}

	// Split by comma to check each parameter
	paramList := bytes.Split(params, []byte(","))
	for _, param := range paramList {
		param = bytes.TrimSpace(param)
		if len(param) == 0 {
			continue
		}

		// Check if parameter has type annotation (contains :)
		if !bytes.Contains(param, []byte(":")) {
			// No type annotation found
			return true
		}
	}

	return false
}

// addTypeInferenceError creates and stores a type inference error
func (l *LambdaProcessor) addTypeInferenceError(lineNum, column int, lineText, params string) {
	// Create error message based on style
	var exampleSyntax string
	switch l.style {
	case StyleTypeScript:
		if strings.Contains(params, ",") {
			exampleSyntax = "(x: int, y: int) => x + y"
		} else {
			exampleSyntax = "(x: int) => x * 2"
		}
	case StyleRust:
		if strings.Contains(params, ",") {
			exampleSyntax = "|x: int, y: int| x + y"
		} else {
			exampleSyntax = "|x: int| x * 2"
		}
	}

	message := "Cannot infer lambda parameter type"
	annotation := "Missing type annotation"
	suggestion := fmt.Sprintf("Add explicit type annotation. Example: %s", exampleSyntax)

	// Create enhanced error (without token.FileSet for preprocessor)
	// We'll create a simple error structure
	err := &dingoerrors.EnhancedError{
		Message:     message,
		Filename:    "source.dingo", // Will be set by caller if available
		Line:        lineNum,
		Column:      column + 1, // Convert 0-indexed to 1-indexed
		Length:      len(params),
		SourceLines: []string{lineText},
		HighlightLine: 0,
		Annotation:  annotation,
		Suggestion:  suggestion,
	}

	l.errors = append(l.errors, err)
}
