package sourcemap

import (
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"testing"

	"github.com/MadAppGang/dingo/pkg/preprocessor"
)

// TestPostASTGenerator_SimpleTransformation tests a single error propagation
func TestPostASTGenerator_SimpleTransformation(t *testing.T) {
	// Create temp directory for test files
	tmpDir := t.TempDir()
	dingoFile := filepath.Join(tmpDir, "test.dingo")
	goFile := filepath.Join(tmpDir, "test.go")

	// Write .dingo file
	dingoContent := `package main

func readConfig(path string) ([]byte, error) {
    let data = os.ReadFile(path)?
    return data
}
`
	if err := os.WriteFile(dingoFile, []byte(dingoContent), 0644); err != nil {
		t.Fatalf("Failed to write .dingo file: %v", err)
	}

	// Write .go file (as if generated by go/printer)
	// Note: go/printer adds package comment, imports, etc.
	goContent := `package main

import "os"

func readConfig(path string) ([]byte, error) {
	tmp0, err0 := os.ReadFile(path) // dingo:e:1
	if err0 != nil {
		return nil, err0
	}
	data := tmp0
	return data, nil
}
`
	if err := os.WriteFile(goFile, []byte(goContent), 0644); err != nil {
		t.Fatalf("Failed to write .go file: %v", err)
	}

	// Create transformation metadata (as preprocessor would emit)
	metadata := []TransformMetadata{
		{
			Type:            "error_prop",
			OriginalLine:    4, // "let data = os.ReadFile(path)?"
			OriginalColumn:  32, // Position of "?"
			OriginalLength:  1,
			OriginalText:    "?",
			GeneratedMarker: "// dingo:e:1",
			ASTNodeType:     "IfStmt",
		},
	}

	// Parse .go file
	fset := token.NewFileSet()
	goAST, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse Go file: %v", err)
	}

	// Generate source map
	gen := NewPostASTGenerator(dingoFile, goFile, fset, goAST, metadata)
	sm, err := gen.Generate()
	if err != nil {
		t.Fatalf("Failed to generate source map: %v", err)
	}

	// Verify mappings exist
	if len(sm.Mappings) == 0 {
		t.Fatal("Expected at least one mapping, got none")
	}

	// Find the error_prop mapping
	var errorPropMapping *preprocessor.Mapping
	for i := range sm.Mappings {
		if sm.Mappings[i].Name == "error_prop" {
			errorPropMapping = &sm.Mappings[i]
			break
		}
	}

	if errorPropMapping == nil {
		t.Fatal("Expected error_prop mapping, found none")
	}

	// CRITICAL TEST: Verify ACTUAL position from FileSet (not predicted)
	// The marker "// dingo:e:1" is on line 6 in the .go file
	if errorPropMapping.GeneratedLine != 6 {
		t.Errorf("Expected GeneratedLine=6 (actual FileSet position), got %d",
			errorPropMapping.GeneratedLine)
	}

	// Verify original position
	if errorPropMapping.OriginalLine != 4 {
		t.Errorf("Expected OriginalLine=4, got %d", errorPropMapping.OriginalLine)
	}

	if errorPropMapping.OriginalColumn != 32 {
		t.Errorf("Expected OriginalColumn=32, got %d", errorPropMapping.OriginalColumn)
	}
}

// TestPostASTGenerator_MultipleTransformations tests multiple error props
func TestPostASTGenerator_MultipleTransformations(t *testing.T) {
	tmpDir := t.TempDir()
	dingoFile := filepath.Join(tmpDir, "test.dingo")
	goFile := filepath.Join(tmpDir, "test.go")

	// .dingo file with 2 error propagations
	dingoContent := `package main

func readConfig(path string) ([]byte, error) {
    let data = os.ReadFile(path)?
    return data
}

func test() error {
    let config = readConfig("config.yaml")?
    return nil
}
`
	if err := os.WriteFile(dingoFile, []byte(dingoContent), 0644); err != nil {
		t.Fatalf("Failed to write .dingo file: %v", err)
	}

	// .go file with markers
	goContent := `package main

import "os"

func readConfig(path string) ([]byte, error) {
	tmp0, err0 := os.ReadFile(path) // dingo:e:1
	if err0 != nil {
		return nil, err0
	}
	data := tmp0
	return data, nil
}

func test() error {
	tmp1, err1 := readConfig("config.yaml") // dingo:e:2
	if err1 != nil {
		return err1
	}
	config := tmp1
	_ = config
	return nil
}
`
	if err := os.WriteFile(goFile, []byte(goContent), 0644); err != nil {
		t.Fatalf("Failed to write .go file: %v", err)
	}

	// Metadata for both transformations
	metadata := []TransformMetadata{
		{
			Type:            "error_prop",
			OriginalLine:    4,
			OriginalColumn:  32,
			OriginalLength:  1,
			OriginalText:    "?",
			GeneratedMarker: "// dingo:e:1",
			ASTNodeType:     "IfStmt",
		},
		{
			Type:            "error_prop",
			OriginalLine:    9,
			OriginalColumn:  41,
			OriginalLength:  1,
			OriginalText:    "?",
			GeneratedMarker: "// dingo:e:2",
			ASTNodeType:     "IfStmt",
		},
	}

	// Parse and generate
	fset := token.NewFileSet()
	goAST, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse Go file: %v", err)
	}

	gen := NewPostASTGenerator(dingoFile, goFile, fset, goAST, metadata)
	sm, err := gen.Generate()
	if err != nil {
		t.Fatalf("Failed to generate source map: %v", err)
	}

	// Find both error_prop mappings
	errorPropMappings := make([]preprocessor.Mapping, 0, 2)
	for _, m := range sm.Mappings {
		if m.Name == "error_prop" {
			errorPropMappings = append(errorPropMappings, m)
		}
	}

	if len(errorPropMappings) != 2 {
		t.Fatalf("Expected 2 error_prop mappings, got %d", len(errorPropMappings))
	}

	// CRITICAL TEST: Verify NO cumulative drift
	// First transformation: line 4 → line 6
	if errorPropMappings[0].OriginalLine != 4 {
		t.Errorf("First mapping: expected OriginalLine=4, got %d",
			errorPropMappings[0].OriginalLine)
	}
	if errorPropMappings[0].GeneratedLine != 6 {
		t.Errorf("First mapping: expected GeneratedLine=6, got %d",
			errorPropMappings[0].GeneratedLine)
	}

	// Second transformation: line 9 → line 15 (actual FileSet position)
	if errorPropMappings[1].OriginalLine != 9 {
		t.Errorf("Second mapping: expected OriginalLine=9, got %d",
			errorPropMappings[1].OriginalLine)
	}
	if errorPropMappings[1].GeneratedLine != 15 {
		t.Errorf("Second mapping: expected GeneratedLine=15 (actual FileSet position, no drift), got %d",
			errorPropMappings[1].GeneratedLine)
	}

	t.Logf("✅ NO CUMULATIVE DRIFT: Both mappings use FileSet positions accurately")
}

// TestPostASTGenerator_IdentityMappings tests unchanged code mapping
func TestPostASTGenerator_IdentityMappings(t *testing.T) {
	tmpDir := t.TempDir()
	dingoFile := filepath.Join(tmpDir, "test.dingo")
	goFile := filepath.Join(tmpDir, "test.go")

	// .dingo file with mix of transformed and untransformed code
	dingoContent := `package main

func simple() int {
    return 42
}

func withError(path string) ([]byte, error) {
    let data = os.ReadFile(path)?
    return data
}
`
	if err := os.WriteFile(dingoFile, []byte(dingoContent), 0644); err != nil {
		t.Fatalf("Failed to write .dingo file: %v", err)
	}

	// .go file
	goContent := `package main

import "os"

func simple() int {
	return 42
}

func withError(path string) ([]byte, error) {
	tmp0, err0 := os.ReadFile(path) // dingo:e:1
	if err0 != nil {
		return nil, err0
	}
	data := tmp0
	return data, nil
}
`
	if err := os.WriteFile(goFile, []byte(goContent), 0644); err != nil {
		t.Fatalf("Failed to write .go file: %v", err)
	}

	// Only one transformation (line 8)
	metadata := []TransformMetadata{
		{
			Type:            "error_prop",
			OriginalLine:    8,
			OriginalColumn:  32,
			OriginalLength:  1,
			OriginalText:    "?",
			GeneratedMarker: "// dingo:e:1",
			ASTNodeType:     "IfStmt",
		},
	}

	// Parse and generate
	fset := token.NewFileSet()
	goAST, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse Go file: %v", err)
	}

	gen := NewPostASTGenerator(dingoFile, goFile, fset, goAST, metadata)
	sm, err := gen.Generate()
	if err != nil {
		t.Fatalf("Failed to generate source map: %v", err)
	}

	// Should have identity mappings for lines 1-7, 9-10
	identityMappings := 0
	errorPropMappings := 0
	for _, m := range sm.Mappings {
		if m.Name == "identity" {
			identityMappings++
		}
		if m.Name == "error_prop" {
			errorPropMappings++
		}
	}

	if errorPropMappings != 1 {
		t.Errorf("Expected 1 error_prop mapping, got %d", errorPropMappings)
	}

	if identityMappings < 5 {
		t.Errorf("Expected at least 5 identity mappings, got %d", identityMappings)
	}

	t.Logf("✅ Generated %d identity mappings for unchanged code", identityMappings)
}

// TestPostASTGenerator_MarkerNotFound tests missing marker handling
func TestPostASTGenerator_MarkerNotFound(t *testing.T) {
	tmpDir := t.TempDir()
	dingoFile := filepath.Join(tmpDir, "test.dingo")
	goFile := filepath.Join(tmpDir, "test.go")

	dingoContent := `package main

func test() int {
    return 42
}
`
	if err := os.WriteFile(dingoFile, []byte(dingoContent), 0644); err != nil {
		t.Fatalf("Failed to write .dingo file: %v", err)
	}

	// .go file WITHOUT marker
	goContent := `package main

func test() int {
	return 42
}
`
	if err := os.WriteFile(goFile, []byte(goContent), 0644); err != nil {
		t.Fatalf("Failed to write .go file: %v", err)
	}

	// Metadata with marker that doesn't exist
	metadata := []TransformMetadata{
		{
			Type:            "error_prop",
			OriginalLine:    3,
			OriginalColumn:  10,
			OriginalLength:  1,
			GeneratedMarker: "// dingo:e:999", // MISSING
		},
	}

	// Parse and generate
	fset := token.NewFileSet()
	goAST, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse Go file: %v", err)
	}

	gen := NewPostASTGenerator(dingoFile, goFile, fset, goAST, metadata)
	sm, err := gen.Generate()
	if err != nil {
		t.Fatalf("Failed to generate source map: %v", err)
	}

	// Should gracefully skip the missing marker
	errorPropMappings := 0
	for _, m := range sm.Mappings {
		if m.Name == "error_prop" {
			errorPropMappings++
		}
	}

	if errorPropMappings != 0 {
		t.Errorf("Expected 0 error_prop mappings (marker missing), got %d", errorPropMappings)
	}

	t.Logf("✅ Gracefully handled missing marker")
}

// TestPostASTGenerator_GenerateFromFiles tests convenience function
func TestPostASTGenerator_GenerateFromFiles(t *testing.T) {
	tmpDir := t.TempDir()
	dingoFile := filepath.Join(tmpDir, "test.dingo")
	goFile := filepath.Join(tmpDir, "test.go")

	dingoContent := `package main

func test() (int, error) {
    let x = getValue()?
    return x
}
`
	if err := os.WriteFile(dingoFile, []byte(dingoContent), 0644); err != nil {
		t.Fatalf("Failed to write .dingo file: %v", err)
	}

	goContent := `package main

func test() (int, error) {
	tmp0, err0 := getValue() // dingo:e:1
	if err0 != nil {
		return 0, err0
	}
	x := tmp0
	return x, nil
}
`
	if err := os.WriteFile(goFile, []byte(goContent), 0644); err != nil {
		t.Fatalf("Failed to write .go file: %v", err)
	}

	metadata := []TransformMetadata{
		{
			Type:            "error_prop",
			OriginalLine:    4,
			OriginalColumn:  20,
			OriginalLength:  1,
			GeneratedMarker: "// dingo:e:1",
		},
	}

	// Use convenience function
	sm, err := GenerateFromFiles(dingoFile, goFile, metadata)
	if err != nil {
		t.Fatalf("GenerateFromFiles failed: %v", err)
	}

	// Verify it worked
	errorPropMappings := 0
	for _, m := range sm.Mappings {
		if m.Name == "error_prop" {
			errorPropMappings++
		}
	}

	if errorPropMappings != 1 {
		t.Errorf("Expected 1 error_prop mapping, got %d", errorPropMappings)
	}

	t.Logf("✅ GenerateFromFiles works correctly")
}

// TestPostASTGenerator_FileSetPositionAccuracy tests FileSet as ground truth
func TestPostASTGenerator_FileSetPositionAccuracy(t *testing.T) {
	tmpDir := t.TempDir()
	dingoFile := filepath.Join(tmpDir, "test.dingo")
	goFile := filepath.Join(tmpDir, "test.go")

	dingoContent := `package main
func test() error {
    let x = foo()?
    return nil
}
`
	if err := os.WriteFile(dingoFile, []byte(dingoContent), 0644); err != nil {
		t.Fatalf("Failed to write .dingo file: %v", err)
	}

	// .go file with specific formatting (go/printer decides this)
	goContent := `package main

func test() error {
	tmp0, err0 := foo() // dingo:e:1
	if err0 != nil {
		return err0
	}
	x := tmp0
	_ = x
	return nil
}
`
	if err := os.WriteFile(goFile, []byte(goContent), 0644); err != nil {
		t.Fatalf("Failed to write .go file: %v", err)
	}

	metadata := []TransformMetadata{
		{
			Type:            "error_prop",
			OriginalLine:    3, // .dingo line
			OriginalColumn:  17,
			OriginalLength:  1,
			GeneratedMarker: "// dingo:e:1",
		},
	}

	// Parse with FileSet
	fset := token.NewFileSet()
	goAST, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse Go file: %v", err)
	}

	// Find the marker comment manually and verify FileSet position
	var markerPos token.Pos
	for _, cg := range goAST.Comments {
		for _, c := range cg.List {
			if c.Text == "// dingo:e:1" {
				markerPos = c.Pos()
				break
			}
		}
	}

	if markerPos == token.NoPos {
		t.Fatal("Could not find marker comment in AST")
	}

	actualPosition := fset.Position(markerPos)
	t.Logf("FileSet position for marker: line=%d, column=%d",
		actualPosition.Line, actualPosition.Column)

	// Generate source map
	gen := NewPostASTGenerator(dingoFile, goFile, fset, goAST, metadata)
	sm, err := gen.Generate()
	if err != nil {
		t.Fatalf("Failed to generate source map: %v", err)
	}

	// Find the mapping
	var mapping *preprocessor.Mapping
	for i := range sm.Mappings {
		if sm.Mappings[i].Name == "error_prop" {
			mapping = &sm.Mappings[i]
			break
		}
	}

	if mapping == nil {
		t.Fatal("No error_prop mapping found")
	}

	// CRITICAL TEST: Mapping must EXACTLY match FileSet position
	if mapping.GeneratedLine != actualPosition.Line {
		t.Errorf("Mapping GeneratedLine=%d does NOT match FileSet line=%d",
			mapping.GeneratedLine, actualPosition.Line)
	}

	if mapping.GeneratedColumn != actualPosition.Column {
		t.Errorf("Mapping GeneratedColumn=%d does NOT match FileSet column=%d",
			mapping.GeneratedColumn, actualPosition.Column)
	}

	t.Logf("✅ Mapping EXACTLY matches FileSet position (ground truth)")
	t.Logf("   Original: line %d → Generated: line %d (FileSet verified)",
		mapping.OriginalLine, mapping.GeneratedLine)
}
