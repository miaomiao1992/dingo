package main

import (
	"errors"
)

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag ResultTag
	err *error
	ok  *string
}

func ResultOk(arg0 string) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func ResultErr(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}
func (r Result) Map(fn func(string) string) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return ResultOk(fn(*r.ok))
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func (r Result) AndThen(fn func(string) Result) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return fn(*r.ok)
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func parseConfig(host Result, port Result, timeout Result) string {

	elem0, elem1, elem2 := host, port, timeout

	switch elem0.tag {
	case ResultTagErr:
		switch elem1.tag {
		default:
			switch elem2.tag {
			default:

				e := *elem0.err
				return "Invalid host: " + e.Error()
			}
		}
	case ResultTagOk:
		switch elem1.tag {
		case ResultTagErr:
			switch elem2.tag {
			default:

				h := *elem0.ok
				e := *elem1.err
				return "Host " + h + " but invalid port: " + e.Error()
			}
		case ResultTagOk:
			switch elem2.tag {
			case ResultTagErr:

				h := *elem0.ok
				p := *elem1.ok
				e := *elem2.err
				return "Config: " + h + ":" + p + " __TUPLE_2__LITERAL__0b5d4307(default timeout, error: " + e.Error() + ")"
			case ResultTagOk:

				h := *elem0.ok
				p := *elem1.ok
				t := *elem2.ok
				return "Config: " + h + ":" + p + " timeout=" + t
			}
		}
	}
	panic("unreachable: match is exhaustive")

}
func main() {
	h := ResultOk("localhost")
	p := ResultOk("8080")
	t := ResultErr(errors.New("timeout not specified"))
	config := parseConfig(h, p, t)
	println(config)
}
