package main

import (
	"errors"
)

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag ResultTag
	ok  *float64
	err *error
}

func ResultOk(arg0 float64) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func ResultErr(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}
func divide(a float64, b float64) Result {
	if b == 0.0 {
		return ResultErr(errors.New("division by zero"))
	}
	return ResultOk(a / b)
}
func handleResult(r Result) string {
	var result interface{}

	scrutinee := r
	switch scrutinee.tag {
	case ResultOkTag:
		val := *scrutinee.resultok

		result = "Success: " + string(int(val))
	case ResultErrTag:
		e := *scrutinee.resulterr

		result = "Error: " + e.Error()
	}
	panic("unreachable: match is exhaustive")
	return result

}
func main() {
	result := divide(10.0, 2.0)
	msg := handleResult(result)
	println(msg)
}
