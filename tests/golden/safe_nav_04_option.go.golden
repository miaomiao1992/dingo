package main

// Test: Safe navigation with Option types only
// Feature: Safe Navigation (?.) - Option Type Support
// Complexity: intermediate

type UserOption_Tag int

const (
	UserOption_Tag_Some UserOption_Tag = iota
	UserOption_Tag_None
)

type UserOption struct {
	tag  UserOption_Tag
	some *User
}

func UserOption_Some(value User) UserOption {
	return UserOption{tag: UserOption_Tag_Some, some: &value}
}

func UserOption_None() UserOption {
	return UserOption{tag: UserOption_Tag_None, some: nil}
}

func (o UserOption) IsSome() bool {
	return o.tag == UserOption_Tag_Some
}

func (o UserOption) IsNone() bool {
	return o.tag == UserOption_Tag_None
}

func (o UserOption) Unwrap() User {
	if o.IsNone() {
		panic("called Unwrap on None")
	}
	return *o.some
}

type ProfileOption_Tag int

const (
	ProfileOption_Tag_Some ProfileOption_Tag = iota
	ProfileOption_Tag_None
)

type ProfileOption struct {
	tag  ProfileOption_Tag
	some *Profile
}

func ProfileOption_Some(value Profile) ProfileOption {
	return ProfileOption{tag: ProfileOption_Tag_Some, some: &value}
}

func ProfileOption_None() ProfileOption {
	return ProfileOption{tag: ProfileOption_Tag_None, some: nil}
}

func (o ProfileOption) IsSome() bool {
	return o.tag == ProfileOption_Tag_Some
}

func (o ProfileOption) IsNone() bool {
	return o.tag == ProfileOption_Tag_None
}

func (o ProfileOption) Unwrap() Profile {
	if o.IsNone() {
		panic("called Unwrap on None")
	}
	return *o.some
}

type StringOption_Tag int

const (
	StringOption_Tag_Some StringOption_Tag = iota
	StringOption_Tag_None
)

type StringOption struct {
	tag  StringOption_Tag
	some *string
}

func StringOption_Some(value string) StringOption {
	return StringOption{tag: StringOption_Tag_Some, some: &value}
}

func StringOption_None() StringOption {
	return StringOption{tag: StringOption_Tag_None, some: nil}
}

func (o StringOption) IsSome() bool {
	return o.tag == StringOption_Tag_Some
}

func (o StringOption) IsNone() bool {
	return o.tag == StringOption_Tag_None
}

func (o StringOption) Unwrap() string {
	if o.IsNone() {
		panic("called Unwrap on None")
	}
	return *o.some
}

type User struct {
	id      int
	profile ProfileOption
}

type Profile struct {
	bio   StringOption
	email string
}

func fetchUser(id int) UserOption {
	if id == 1 {
		bio := StringOption_Some("Software Engineer")
		prof := ProfileOption_Some(Profile{bio: bio, email: "alice@example.com"})
		return UserOption_Some(User{id: 1, profile: prof})
	}
	return UserOption_None()
}

func main() {
	// Test 1: Full Option chain
	user := fetchUser(1)
	bio := func() StringOption {
		if user.IsNone() {
			return StringOption_None()
		}
		_user := user.Unwrap()

		if _user.profile.IsNone() {
			return StringOption_None()
		}
		_profile := _user.profile.Unwrap()

		return _profile.bio
	}()
	println("Bio:", bio)

	// Test 2: None propagation
	noUser := fetchUser(0)
	noBio := func() StringOption {
		if noUser.IsNone() {
			return StringOption_None()
		}
		_user := noUser.Unwrap()

		if _user.profile.IsNone() {
			return StringOption_None()
		}
		_profile := _user.profile.Unwrap()

		return _profile.bio
	}()
	println("No Bio:", noBio)

	// Test 3: Intermediate None
	partialUser := UserOption_Some(User{id: 2, profile: ProfileOption_None()})
	partialBio := func() StringOption {
		if partialUser.IsNone() {
			return StringOption_None()
		}
		_user := partialUser.Unwrap()

		if _user.profile.IsNone() {
			return StringOption_None()
		}
		_profile := _user.profile.Unwrap()

		return _profile.bio
	}()
	println("Partial Bio:", partialBio)
}
