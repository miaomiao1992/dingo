package main

type UserOptionTag uint8

const (
	UserOptionTagSome UserOptionTag = iota
	UserOptionTagNone
)

type UserOption struct {
	tag  UserOptionTag
	some *User
}

func UserOptionSome(arg0 User) UserOption {
	return UserOption{tag: UserOptionTagSome, some: &arg0}
}
func UserOptionNone() UserOption {
	return UserOption{tag: UserOptionTagNone}
}
func (e UserOption) IsSome() bool {
	return e.tag == UserOptionTagSome
}
func (e UserOption) IsNone() bool {
	return e.tag == UserOptionTagNone
}
func (o UserOption) Map(fn func(User) User) UserOption {
	switch o.tag {
	case UserOptionTagSome:
		if o.some != nil {
			return UserOptionSome(fn(*o.some))
		}
	case UserOptionTagNone:
		return o
	}
	panic("invalid UserOption state")
}
func (o UserOption) AndThen(fn func(User) UserOption) UserOption {
	switch o.tag {
	case UserOptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case UserOptionTagNone:
		return o
	}
	panic("invalid UserOption state")
}

type StringOptionTag uint8

const (
	StringOptionTagSome StringOptionTag = iota
	StringOptionTagNone
)

type StringOption struct {
	tag  StringOptionTag
	some *string
}
func StringOptionSome(arg0 string) StringOption {
	return StringOption{tag: StringOptionTagSome, some: &arg0}
}
func StringOptionNone() StringOption {
	return StringOption{tag: StringOptionTagNone}
}
func (e StringOption) IsSome() bool {
	return e.tag == StringOptionTagSome
}
func (e StringOption) IsNone() bool {
	return e.tag == StringOptionTagNone
}
func (o StringOption) Map(fn func(string) string) StringOption {
	switch o.tag {
	case StringOptionTagSome:
		if o.some != nil {
			return StringOptionSome(fn(*o.some))
		}
	case StringOptionTagNone:
		return o
	}
	panic("invalid StringOption state")
}
func (o StringOption) AndThen(fn func(string) StringOption) StringOption {
	switch o.tag {
	case StringOptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case StringOptionTagNone:
		return o
	}
	panic("invalid StringOption state")
}

type User struct {
	name    string
	profile *Profile
}
type Profile struct {
	bio string
}
func main() {

	user := getUser()
	profileOpt := func() __INFER__ {
		if user.IsNone() {
			return __INFER___None()
		}
		user1 := user.Unwrap()
		return user1.profile
	}()
	bioOpt := __SAFE_NAV_INFER__(profileOpt, "bio")
	bio := func() __INFER__ {
		if bioOpt.IsSome() {
			return __UNWRAP__(bioOpt)
		}
		return "No bio"
	}()

	userPtr := getUserPtr()
	nameOpt := func() __INFER__ {
		if userPtr == nil {
			return nil
		}
		return userPtr.name
	}()
	name := func() __INFER__ {
		if nameOpt.IsSome() {
			return __UNWRAP__(nameOpt)
		}
		return "Anonymous"
	}()

	user2 := UserOptionSome(User{
		name:    "Bob",
		profile: &Profile{bio: "Engineer"},
	})
	profileOpt2 := func() __INFER__ {
		if user2.IsNone() {
			return __INFER___None()
		}
		user22 := user2.Unwrap()
		return user22.profile
	}()
	bioOpt2 := __SAFE_NAV_INFER__(profileOpt2, "bio")
	profile := func() __INFER__ {
		if bioOpt2.IsSome() {
			return __UNWRAP__(bioOpt2)
		}
		return "Default bio"
	}()

	user3 := getUser()
	emailOpt := func() __INFER__ {
		if user3.IsNone() {
			return __INFER___None()
		}
		user33 := user3.Unwrap()
		return user33.getEmail()
	}()
	email := func() __INFER__ {
		if emailOpt.IsSome() {
			return __UNWRAP__(emailOpt)
		}
		return "no-email"
	}()

	println("Bio:", bio)
	println("Name:", name)
	println("Profile:", profile)
	println("Email:", email)
}
func getUser() UserOption {
	return UserOptionNone()
}
func getUserPtr() *User {
	return nil
}
func (u User) getEmail() *string {
	email := u.name + "@example.com"
	return &email
}
