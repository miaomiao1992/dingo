package main

// Test: Combined safe navigation and null coalescing integration
// Feature: Complex real-world scenarios with ?. and ??
// Complexity: high
// Description: Demonstrates realistic API response handling, config parsing,
// and nested access patterns with fallback values

import (
	"encoding/json"
	"fmt"
)

// API response models
enum UserOption {
	Some(User),
	None,
}

enum AddressOption {
	Some(Address),
	None,
}

enum StringOption {
	Some(string),
	None,
}

enum IntOption {
	Some(int),
	None,
}

type User struct {
	id      int
	name    string
	profile ProfileOption
	address AddressOption
}

enum ProfileOption {
	Some(Profile),
	None,
}

type Profile struct {
	bio        StringOption
	website    StringOption
	reputation IntOption
}

type Address struct {
	street  string
	city    string
	country StringOption
}

// Configuration models
type Config struct {
	database *DatabaseConfig
	cache    *CacheConfig
	api      *APIConfig
}

type DatabaseConfig struct {
	host     *string
	port     *int
	timeout  *int
	maxConns *int
}

type CacheConfig struct {
	enabled  *bool
	ttl      *int
	maxSize  *int
}

type APIConfig struct {
	baseURL     *string
	timeout     *int
	retries     *int
	rateLimiter *RateLimiterConfig
}

type RateLimiterConfig struct {
	enabled      *bool
	requestsPerSec *int
}

func main() {
	// ===== Test 1: API Response Handling =====
	// Scenario: Fetch user data from API, extract nested optional fields
	let apiUser: UserOption = fetchUserFromAPI(123)

	// Extract user bio with fallback
	let userBio = apiUser?.profile?.bio ?? "No bio available"
	fmt.Println("User bio:", userBio)

	// Extract website, handle multiple levels of optionality
	let userWebsite = apiUser?.profile?.website ?? "https://example.com"
	fmt.Println("Website:", userWebsite)

	// Extract reputation with numeric fallback
	let reputation = apiUser?.profile?.reputation ?? 0
	fmt.Println("Reputation:", reputation)

	// Chained property access with address
	let userCity = apiUser?.address?.city ?? "Unknown City"
	let userCountry = apiUser?.address?.country ?? "Unknown Country"
	fmt.Printf("Location: %s, %s\n", userCity, userCountry)

	// ===== Test 2: Config Parsing with Fallbacks =====
	// Scenario: Load config, use sensible defaults for missing values
	let config: *Config = loadConfig()

	// Database configuration
	let dbHost = config?.database?.host ?? "localhost"
	let dbPort = config?.database?.port ?? 5432
	let dbTimeout = config?.database?.timeout ?? 30
	let dbMaxConns = config?.database?.maxConns ?? 10
	fmt.Printf("DB: %s:%d (timeout=%ds, maxConns=%d)\n", dbHost, dbPort, dbTimeout, dbMaxConns)

	// Cache configuration
	let cacheEnabled = config?.cache?.enabled ?? false
	let cacheTTL = config?.cache?.ttl ?? 300
	let cacheMaxSize = config?.cache?.maxSize ?? 1000
	fmt.Printf("Cache: enabled=%v, ttl=%ds, maxSize=%d\n", cacheEnabled, cacheTTL, cacheMaxSize)

	// API configuration with nested rate limiter
	let apiURL = config?.api?.baseURL ?? "https://api.example.com"
	let apiTimeout = config?.api?.timeout ?? 60
	let apiRetries = config?.api?.retries ?? 3
	let rateLimitEnabled = config?.api?.rateLimiter?.enabled ?? true
	let rateLimitRPS = config?.api?.rateLimiter?.requestsPerSec ?? 100
	fmt.Printf("API: %s (timeout=%ds, retries=%d)\n", apiURL, apiTimeout, apiRetries)
	fmt.Printf("Rate Limit: enabled=%v, rps=%d\n", rateLimitEnabled, rateLimitRPS)

	// ===== Test 3: Mixed Property and Method Calls =====
	// Scenario: Extract data using both property access and method calls
	let user2: UserOption = getActiveUser()

	// Method call with fallback
	let displayName = user2?.getDisplayName() ?? "Anonymous"
	fmt.Println("Display name:", displayName)

	// Chained: property then method
	let profileURL = user2?.profile?.formatURL() ?? "/default-profile"
	fmt.Println("Profile URL:", profileURL)

	// Method with args, then property
	let formattedAddress = user2?.formatAddress("short")?.city ?? "N/A"
	fmt.Println("Address:", formattedAddress)

	// ===== Test 4: Expression-level Fallbacks =====
	// Scenario: Use function calls as fallback values
	let user3: UserOption = findUser("jack")

	let city3 = user3?.address?.city ?? getDefaultCity()
	let country3 = user3?.address?.country ?? detectCountryFromIP()
	fmt.Printf("Detected location: %s, %s\n", city3, country3)

	// Chained fallbacks (a ?? b ?? c)
	let primaryEmail = user3?.profile?.getEmail() ?? user3?.getBackupEmail() ?? "support@example.com"
	fmt.Println("Contact email:", primaryEmail)

	// ===== Test 5: Nested Safe Navigation in Expressions =====
	// Scenario: Complex expressions with safe nav
	let user4: UserOption = getUser(456)
	let user5: UserOption = getUser(789)

	// Use safe nav result in comparison
	let areSameCity = (user4?.address?.city ?? "") == (user5?.address?.city ?? "")
	fmt.Println("Same city?", areSameCity)

	// Use in JSON encoding
	let jsonData = map[string]interface{}{
		"name":    user4?.name ?? "unknown",
		"city":    user4?.address?.city ?? "unknown",
		"country": user4?.address?.country ?? "unknown",
		"bio":     user4?.profile?.bio ?? "",
	}
	json.Marshal(jsonData)
}

// ===== Helper Functions =====

func fetchUserFromAPI(id int) UserOption {
	// Simulate API call that may return None
	if id == 123 {
		let profile = ProfileOptionSome(Profile{
			bio:        StringOptionSome("Software engineer"),
			website:    StringOptionSome("https://github.com/user"),
			reputation: IntOptionSome(1500),
		})
		let address = AddressOptionSome(Address{
			street:  "123 Main St",
			city:    "San Francisco",
			country: StringOptionSome("USA"),
		})
		return UserOptionSome(User{
			id:      123,
			name:    "Alice",
			profile: profile,
			address: address,
		})
	}
	let none = UserOption{}
	return none
}

func loadConfig() *Config {
	// Simulate partial config loading (some fields nil)
	let dbHost = "db.example.com"
	let dbPort = 3306
	let cacheEnabled = true

	return &Config{
		database: &DatabaseConfig{
			host:    &dbHost,
			port:    &dbPort,
			timeout: nil, // Will use default
		},
		cache: &CacheConfig{
			enabled: &cacheEnabled,
			ttl:     nil, // Will use default
		},
		api: nil, // Entire API config missing, use defaults
	}
}

func getActiveUser() UserOption {
	let none = UserOption{}
	return none
}

func findUser(username string) UserOption {
	let none = UserOption{}
	return none
}

func getUser(id int) UserOption {
	let none = UserOption{}
	return none
}

func getDefaultCity() string {
	return "San Francisco"
}

func detectCountryFromIP() string {
	return "USA"
}

// User methods
func (u User) getDisplayName() StringOption {
	if u.name != "" {
		return StringOptionSome(u.name)
	}
	let none = StringOption{}
	return none
}

func (u User) getBackupEmail() StringOption {
	return StringOptionSome("backup@example.com")
}

func (u User) formatAddress(format string) AddressOption {
	return u.address
}

// Profile methods
func (p Profile) formatURL() StringOption {
	return StringOptionSome("/profile/123")
}

func (p Profile) getEmail() StringOption {
	let none = StringOption{}
	return none
}
