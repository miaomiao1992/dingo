// Test: None constant context inference
// Feature: None type inference from context
// Description: Tests that None constants infer their types from surrounding context

package main

// Test 1: Return statement context
// dingo:n:0
type OptionTag uint8

const (
	OptionTagSome OptionTag = iota
	OptionTagNone
)

type Option struct {
	tag  OptionTag
	some *int
}

func OptionSome(arg0 int) Option {
	return Option{tag: OptionTagSome, some: &arg0}
}
func OptionNone() Option {
	return Option{tag: OptionTagNone}
}
func (e Option) IsSome() bool {
	return e.tag == OptionTagSome
}
func (e Option) IsNone() bool {
	return e.tag == OptionTagNone
}
func (o Option) Map(fn func(int) int) Option {
	switch o.tag {
	case OptionTagSome:
		if o.some != nil {
			return OptionSome(fn(*o.some))
		}
	case OptionTagNone:
		return o
	}
	panic("invalid Option state")
}
func (o Option) AndThen(fn func(int) Option) Option {
	switch o.tag {
	case OptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case OptionTagNone:
		return o
	}
	panic("invalid Option state")
}
func (o Option) Unwrap() int {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func getAge() Option {
	return OptionNone() // Inferred as Option[int] from return type
}

// Test 2: Function call parameter context
func processAge(age Option) {
	println("Processing age")
}
func main() {
	processAge(OptionNone()) // Inferred as Option[int] from parameter type
	explicitType()
	assignmentContext()
	user := createUser()
	println("Created user:", user.name)
}

// Test 3: Explicit type annotation (always valid)
func explicitType() {
	var x Option = OptionNone() // Explicit type annotation
	println("x is None")
}

// Test 4: Assignment to typed variable
func assignmentContext() {
	var age Option
	age = OptionNone() // Inferred from variable type
	println("age is None")
}

// Test 5: Struct field context
type User struct {
	name string
	age  Option
}
func createUser() User {
	return User{
		name: "Alice",
		age:  OptionNone(), // Inferred as Option[int] from field type
	}
}

// ERROR CASE: This should fail compilation
// Uncomment to test error handling
// fn ambiguousNone() {
//     x := None  // ERROR: cannot infer type for None constant
// }
