package main

import (
	"errors"
)

const (
	patternsTag_Ok patternsTag = iota
	patternsTag_Err
)

type patterns struct {
	tag   patternsTag
	ok_0  *Value
	err_0 *error
}

func patterns_Ok(arg0 Value) patterns {
	return patterns{tag: patternsTag_Ok, ok_0: &arg0}
}
func patterns_Err(arg0 error) patterns {
	return patterns{tag: patternsTag_Err, err_0: &arg0}
}
func (e patterns) IsOk() bool {
	return e.tag == patternsTag_Ok
}
func (e patterns) IsErr() bool {
	return e.tag == patternsTag_Err
}

type ValueTag uint8

const (
	ValueTag_Int ValueTag = iota
	ValueTag_String
)

type Value struct {
	tag      ValueTag
	int_0    *int
	string_0 *string
}
func Value_Int(arg0 int) Value {
	return Value{tag: ValueTag_Int, int_0: &arg0}
}
func Value_String(arg0 string) Value {
	return Value{tag: ValueTag_String, string_0: &arg0}
}
func (e Value) IsInt() bool {
	return e.tag == ValueTag_Int
}
func (e Value) IsString() bool {
	return e.tag == ValueTag_String
}
func processResult(r Result) string {
	var __match_result_0 interface{}

	__match_0 := r
	switch __match_0.tag {
	case ResultTag_Ok:
		__Result_Ok_nested := *__match_0.ok_0
		switch __Result_Ok_nested.tag {
		case ValueTag_Int:
			n := *__Result_Ok_nested.int_0
			__match_result_0 = "Got integer: " + string(n)
		case ValueTag_String:
			s := *__Result_Ok_nested.string_0
			__match_result_0 = "Got string: " + s
		}
	case ResultTag_Err:
		e := *__match_0.err_0

		__match_result_0 = "Error: " + e.Error()
	}
	panic("unreachable: match is exhaustive")
	return __match_result_0

}
func main() {
	result1 := Result_Ok(Value_Int(42))
	result2 := Result_Ok(Value_String("hello"))
	result3 := Result_Err(errors.New("failed"))

	println(processResult(result1))
	println(processResult(result2))
	println(processResult(result3))
}
