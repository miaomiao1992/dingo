package main

import "errors"

// Test: Nested pattern matching
// Feature: Match with nested // dingo:n:1
type patternsTag uint8

const (
	patternsTagOk patternsTag = iota
	patternsTagErr
)

type patterns struct {
	tag patternsTag
	err *error
	ok  *Value
}

func patternsOk(arg0 Value) patterns {
	return patterns{tag: patternsTagOk, ok: &arg0}
}
func patternsErr(arg0 error) patterns {
	return patterns{tag: patternsTagErr, err: &arg0}
}
func (e patterns) IsOk() bool {
	return e.tag == patternsTagOk
}
func (e patterns) IsErr() bool {
	return e.tag == patternsTagErr
}
func (r patterns) Map(fn func(Value) Value) patterns {
	switch r.tag {
	case patternsTagOk:
		if r.ok != nil {
			return patternsOk(fn(*r.ok))
		}
	case patternsTagErr:
		return r
	}
	panic("invalid patterns state")
}
func (r patterns) AndThen(fn func(Value) patterns) patterns {
	switch r.tag {
	case patternsTagOk:
		if r.ok != nil {
			return fn(*r.ok)
		}
	case patternsTagErr:
		return r
	}
	panic("invalid patterns state")
}

// dingo:n:0
type ValueTag uint8

const (
	ValueTagInt ValueTag = iota
	ValueTagString
)

type Value struct {
	tag    ValueTag
	int    *int
	string *string
}
func ValueInt(arg0 int) Value {
	return Value{tag: ValueTagInt, int: &arg0}
}
func ValueString(arg0 string) Value {
	return Value{tag: ValueTagString, string: &arg0}
}
func (e Value) IsInt() bool {
	return e.tag == ValueTagInt
}
func (e Value) IsString() bool {
	return e.tag == ValueTagString
}
func processResult(r Result) string {
	var result interface{}
	// DINGO_MATCH_START: r
	scrutinee := r
	switch scrutinee.tag {
	case ResultTagOk:
		nestedResultOk := *scrutinee.resultok
		switch nestedResultOk.tag {
		case ValueTagInt:
			n := *nestedResultOk.int
			result = "Got integer: " + string(n)
		case ValueTagString:
			s := *nestedResultOk.string
			result = "Got string: " + s
		}
	case ResultTagErr:
		e := *scrutinee.err
		// DINGO_PATTERN: ResultErr(e)
		result = "Error: " + e.Error()
	}
	panic("unreachable: match is exhaustive")
	return result
	// DINGO_MATCH_END

}
func main() {
	result1 := ResultOk(Value_Int(42))
	result2 := ResultOk(Value_String("hello"))
	result3 := ResultErr(errors.New("failed"))

	println(processResult(result1))
	println(processResult(result2))
	println(processResult(result3))
}
