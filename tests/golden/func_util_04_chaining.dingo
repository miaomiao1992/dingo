package main

// Test: Chaining functional utilities
// Feature: Method chaining with map/filter/reduce
// Complexity: advanced

func map(arr: []int, f: func(int) int) []int {
	let result = make([]int, len(arr))
	for i, v := range arr {
		result[i] = f(v)
	}
	return result
}

func filter(arr: []int, predicate: func(int) bool) []int {
	let result = []int{}
	for _, v := range arr {
		if predicate(v) {
			result = append(result, v)
		}
	}
	return result
}

func reduce(arr: []int, initial: int, f: func(int, int) int) int {
	let result = initial
	for _, v := range arr {
		result = f(result, v)
	}
	return result
}

func main() {
	let numbers = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	// Chain: filter evens, double them, sum
	let result = reduce(
		map(
			filter(numbers, |x| x%2 == 0),
			|x| x * 2,
		),
		0,
		|acc, x| acc + x,
	)

	println("Result:", result)
}
