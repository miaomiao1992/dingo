package main

import "errors"

// dingo:n:0
type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag ResultTag
	err *error
	ok  *float64
}

func ResultOk(arg0 float64) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func ResultErr(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}
func (r Result) Map(fn func(float64) float64) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return ResultOk(fn(*r.ok))
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func (r Result) AndThen(fn func(float64) Result) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return fn(*r.ok)
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func divide(a float64, b float64) Result {
	if b == 0.0 {
		return ResultErr(errors.New("division by zero"))
	}
	return ResultOk(a / b)
}
func main() {
	var resul t = divide(10.0, 2.0)
	if result.IsOk() {
		v := *result.ok
		_ = v
	}
}
