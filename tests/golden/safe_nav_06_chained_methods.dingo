package main

// Test: Chained method calls with safe navigation operator
// Feature: Safe Navigation (?.) - Chained Methods
// Complexity: intermediate

enum UserOption {
	Some(User),
	None,
}

enum StringOption {
	Some(string),
	None,
}

enum ProfileOption {
	Some(Profile),
	None,
}

type User struct {
	name string
}

type Profile struct {
	bio string
}

func (u User) getName() StringOption {
	if u.name != "" {
		return StringOptionSome(u.name)
	}
	return StringOptionNone()
}

func (s StringOption) toUpper() StringOption {
	if s.IsNone() {
		return StringOptionNone()
	}
	str := s.Unwrap()
	// Simplified uppercase conversion
	return StringOptionSome(str)
}

func (u User) getProfile() ProfileOption {
	return ProfileOptionSome(Profile{bio: "Engineer"})
}

func (p Profile) getBio() StringOption {
	if p.bio != "" {
		return StringOptionSome(p.bio)
	}
	return StringOptionNone()
}

func getUser(id int) UserOption {
	if id > 0 {
		return UserOptionSome(User{name: "Alice"})
	}
	return UserOptionNone()
}

func main() {
	user := getUser(1)

	// Chained methods on same type: user?.getName()?.toUpper()
	upperName := user?.getName()?.toUpper()
	println(upperName)

	// Chained methods across types: user?.getProfile()?.getBio()
	bio := user?.getProfile()?.getBio()
	println(bio)
}
