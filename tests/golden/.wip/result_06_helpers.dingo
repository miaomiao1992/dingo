package main

import (
	"errors"
	"fmt"
)

// Test: Complete Result<T,E> helper method suite
// Feature: IsOk, IsErr, Unwrap, UnwrapOr, UnwrapOrElse, Map, MapErr, Filter, AndThen, OrElse, And, Or
// Complexity: comprehensive

enum Result {
	Ok(int),
	Err(error),
}

func divide(a int, b int) Result {
	if b == 0 {
		return Result_Err(errors.New("division by zero"))
	}
	return Result_Ok(a / b)
}

func main() {
	// Test 1: IsOk and IsErr
	okResult := Ok(42)
	errResult := Err(errors.New("fail"))

	if okResult.IsOk() {
		fmt.Println("IsOk works:", true)
	}

	if errResult.IsErr() {
		fmt.Println("IsErr works:", true)
	}

	// Test 2: Unwrap (panics on Err)
	value := okResult.Unwrap()
	fmt.Println("Unwrap:", value)

	// Test 3: UnwrapOr (provides default)
	safeValue := errResult.UnwrapOr(0)
	fmt.Println("UnwrapOr:", safeValue)

	// Test 4: UnwrapOrElse (computes default from error)
	computedValue := errResult.UnwrapOrElse(func(e error) int {
		return -1
	})
	fmt.Println("UnwrapOrElse:", computedValue)

	// Test 5: Map (transforms Ok value)
	doubled := divide(10, 2).Map(func(x int) interface{} {
		return x * 2
	})
	fmt.Println("Map result:", doubled)

	// Test 6: MapErr (transforms Err value)
	mapped := divide(10, 0).MapErr(func(e error) interface{} {
		return fmt.Errorf("wrapped: %w", e)
	})
	fmt.Println("MapErr result:", mapped)

	// Test 7: Filter (converts Ok to Err if predicate fails)
	filtered := divide(10, 5).Filter(func(x int) bool {
		return x > 3
	}, errors.New("value too small"))
	fmt.Println("Filter passed:", filtered.IsOk())

	failedFilter := divide(10, 5).Filter(func(x int) bool {
		return x > 10
	}, errors.New("value too small"))
	fmt.Println("Filter failed:", failedFilter.IsErr())

	// Test 8: AndThen (chain operations)
	chained := divide(20, 2).AndThen(func(x int) interface{} {
		return divide(x, 2)
	})
	fmt.Println("AndThen:", chained)

	// Test 9: OrElse (recover from Err)
	recovered := divide(10, 0).OrElse(func(e error) interface{} {
		return Ok(0) // Default to 0 on error
	})
	fmt.Println("OrElse:", recovered)

	// Test 10: And (returns other if Ok, Err if Err)
	andResult := divide(10, 2).And(divide(20, 4))
	fmt.Println("And:", andResult)

	// Test 11: Or (returns first Ok, or last Err)
	orResult := divide(10, 0).Or(divide(20, 2))
	fmt.Println("Or:", orResult.IsOk())
}
