package main

import "fmt"

// Example 1: Non-exhaustive Result match (missing Err case)
// This should produce a compile error
func handleResultNonExhaustive(result: Result<int, string>) -> int {
	match result {
		Ok(x) => x * 2
		// ERROR: non-exhaustive match, missing cases: Err
	}
}

// Example 2: Exhaustive Result match with wildcard
func handleResultExhaustive(result: Result<int, string>) -> int {
	match result {
		Ok(x) => x * 2,
		_ => 0
	}
}

// Example 3: Non-exhaustive Option match (missing None case)
// This should produce a compile error
func handleOptionNonExhaustive(opt: Option<int>) -> int {
	match opt {
		Some(x) => x
		// ERROR: non-exhaustive match, missing cases: None
	}
}

// Example 4: Exhaustive Option match with all cases
func handleOptionExhaustive(opt: Option<int>) -> int {
	match opt {
		Some(x) => x,
		None => 0
	}
}

// Example 5: Wildcard covers all remaining cases
func handleWithWildcard(result: Result<User, Error>) -> string {
	match result {
		Ok(user) => user.name,
		_ => "Unknown"
	}
}

// Example 6: Demonstrating proper error message format
func demonstrateErrorMessage(result: Result<int, string>) {
	// This will produce:
	// error: non-exhaustive match, missing cases: Err
	//   --> pattern_match_02_exhaustive.dingo:XX:YY
	//   |
	// XX | match result {
	//    | ^^^^^^^^^^^^^^ missing Err case
	//   |
	// help: add a wildcard arm: _ => ...
	match result {
		Ok(x) => fmt.Println(x)
	}
}

type User struct {
	name string
}

type Error struct {
	message string
}
