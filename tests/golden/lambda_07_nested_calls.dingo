// Golden Test: Lambda with Nested Function Calls (Multiple Arguments)
// Tests that lambda body parsing correctly handles function calls with multiple arguments
// Issue: Regex pattern `[^,)]+` was truncating bodies at first comma

package main

import (
	"fmt"
	"strings"
)

// Helper functions for testing
func transform(x int, multiplier int, offset int) int {
	return x*multiplier + offset
}

func validate(user string, context string) bool {
	return len(user) > 0 && len(context) > 0
}

func combine(a int, x int, seed int) int {
	return a + x + seed
}

func formatUser(name string, age int, city string) string {
	return fmt.Sprintf("%s (%d) from %s", name, age, city)
}

func main() {
	// Test 1: Simple function call with multiple arguments
	numbers := []int{1, 2, 3, 4, 5}
	result1 := map(numbers, (x: int): int => transform(x, 2, 10))
	fmt.Println("Transform with multiple args:", result1) // [12, 14, 16, 18, 20]

	// Test 2: Nested function calls in lambda body
	result2 := map(numbers, (x: int): int => transform(transform(x, 2, 0), 3, 1))
	fmt.Println("Nested transforms:", result2) // [7, 13, 19, 25, 31]

	// Test 3: Filter with validation function (multiple args)
	users := []string{"alice", "bob", "", "charlie"}
	context := "production"
	result3 := filter(users, (u: string): bool => validate(u, context))
	fmt.Println("Valid users:", result3) // [alice, bob, charlie]

	// Test 4: Reduce with combine function (multiple args)
	seed := 100
	result4 := reduce(numbers, (acc: int, x: int): int => combine(acc, x, seed), 0)
	fmt.Println("Combined with seed:", result4)

	// Test 5: Complex expression with multiple function calls
	names := []string{"Alice", "Bob", "Charlie"}
	ages := []int{25, 30, 35}
	cities := []string{"NYC", "LA", "SF"}

	result5 := []string{}
	for i := 0; i < len(names); i++ {
		formatted := formatUser(names[i], ages[i], cities[i])
		result5 = append(result5, formatted)
	}
	fmt.Println("Formatted users:", result5)

	// Test 6: Lambda in method chain with multiple args
	data := []string{"hello", "world", "test"}
	result6 := map(
		filter(data, (s: string): bool => len(s) > 3),
		(s: string): string => strings.Repeat(s, 2),
	)
	fmt.Println("Filtered and repeated:", result6) // [hellohello, worldworld, testtest]

	// Test 7: Rust-style lambda with function calls (if enabled)
	// result7 := map(numbers, |x: int| -> int { transform(x, 3, 5) })
	// fmt.Println("Rust-style with args:", result7)
}

// Helper map function
func map[T, R any](slice []T, fn func(T) R) []R {
	result := make([]R, len(slice))
	for i, v := range slice {
		result[i] = fn(v)
	}
	return result
}

// Helper filter function
func filter[T any](slice []T, fn func(T) bool) []T {
	result := []T{}
	for _, v := range slice {
		if fn(v) {
			result = append(result, v)
		}
	}
	return result
}

// Helper reduce function
func reduce[T, R any](slice []T, fn func(R, T) R, initial R) R {
	result := initial
	for _, v := range slice {
		result = fn(result, v)
	}
	return result
}
