package main

import (
	"database/sql"
	"encoding/json"
	"errors"
	"net/http"
	"strings"
)

type UserStatusTag uint8

const (
	UserStatusTagActive UserStatusTag = iota
	UserStatusTagPending
	UserStatusTagSuspended
)

type UserStatus struct {
	tag UserStatusTag
}

func UserStatus_Active() UserStatus {
	return UserStatus{tag: UserStatusTagActive}
}
func UserStatus_Pending() UserStatus {
	return UserStatus{tag: UserStatusTagPending}
}
func UserStatus_Suspended() UserStatus {
	return UserStatus{tag: UserStatusTagSuspended}
}
func (e UserStatus) IsActive() bool {
	return e.tag == UserStatusTagActive
}
func (e UserStatus) IsPending() bool {
	return e.tag == UserStatusTagPending
}
func (e UserStatus) IsSuspended() bool {
	return e.tag == UserStatusTagSuspended
}

type User struct {
	ID       int
	Username string
	Email    string
	Status   UserStatus
}

type RegisterRequest struct {
	Username string
	Email    string
	Password string
}

func validateEmail(email string) (string, error) {
	if !strings.Contains(email, "@") || !strings.Contains(email, ".") {
		return "", errors.New("invalid email format")
	}
	return email, nil
}

func validatePassword(password string) (string, error) {
	if len(password) < 8 {
		return "", errors.New("password must be at least 8 characters")
	}
	return password, nil
}

func validateUsername(username string) (string, error) {
	if len(username) < 3 {
		return "", errors.New("username must be at least 3 characters")
	}
	if len(username) > 20 {
		return "", errors.New("username too long")
	}
	return username, nil
}

func checkUserExists(db *sql.DB, email string) (bool, error) {
	var exists bool
	query := "SELECT EXISTS(SELECT 1 FROM users WHERE email = ?)"
	err := db.QueryRow(query, email).Scan(&exists)
	if err != nil {
		return false, err
	}
	return exists, nil
}

func hashPassword(password string) (string, error) {

	if password == "" {
		return "", errors.New("cannot hash empty password")
	}
	hashed := "hashed_" + password
	return hashed, nil
}

func saveUser(db *sql.DB, username string, email string, hashedPwd string, status UserStatus) (int64, error) {
	query := "INSERT INTO users (username, email, password, status) VALUES (?, ?, ?, ?)"
	result, err := db.Exec(query, username, email, hashedPwd, status)
	if err != nil {
		return 0, err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}

	return id, nil
}

func registerUser(db *sql.DB, req RegisterRequest) (User, error) {

	__tmp0, __err0 := validateEmail(req.Email)

	if __err0 != nil {
		return User{}, __err0
	}

	var email = __tmp0
	__tmp1, __err1 := validatePassword(req.Password)

	if __err1 != nil {
		return User{}, __err1
	}

	var password = __tmp1
	__tmp2, __err2 := validateUsername(req.Username)

	if __err2 != nil {
		return User{}, __err2
	}

	var username = __tmp2

	__tmp3, __err3 := checkUserExists(db, email)

	if __err3 != nil {
		return User{}, __err3
	}

	var exists = __tmp3
	if exists {
		return User{}, errors.New("user already exists")
	}

	__tmp4, __err4 := hashPassword(password)

	if __err4 != nil {
		return User{}, __err4
	}

	var hashedPassword = __tmp4

	__tmp5, __err5 := saveUser(db, username, email, hashedPassword, UserStatus_Pending())

	if __err5 != nil {
		return User{}, __err5
	}

	var id = __tmp5

	user := User{
		ID:       int(id),
		Username: username,
		Email:    email,
		Status:   UserStatus_Pending(),
	}

	return user, nil
}

func handleRegister(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req RegisterRequest

		err := json.NewDecoder(r.Body).Decode(&req)
		if err != nil {
			http.Error(w, "invalid request body", http.StatusBadRequest)
			return
		}

		user, err := registerUser(db, req)
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(user)
	}
}
