package main

// Test: Exhaustive pattern matching
// Feature: Compiler ensures all cases covered
// Complexity: intermediate

// dingo:n:0
type ColorTag uint8

const (
	ColorTagRed ColorTag = iota
	ColorTagGreen
	ColorTagBlue
	ColorTagRGB
)

type Color struct {
	tag   ColorTag
	rgb_b *int
	rgb_g *int
	rgb_r *int
}

func ColorRed() Color {
	return Color{tag: ColorTagRed}
}
func ColorGreen() Color {
	return Color{tag: ColorTagGreen}
}
func ColorBlue() Color {
	return Color{tag: ColorTagBlue}
}
func ColorRGB(r int, g int, b int) Color {
	return Color{tag: ColorTagRGB, rgb_r: &r, rgb_g: &g, rgb_b: &b}
}
func (e Color) IsRed() bool {
	return e.tag == ColorTagRed
}
func (e Color) IsGreen() bool {
	return e.tag == ColorTagGreen
}
func (e Color) IsBlue() bool {
	return e.tag == ColorTagBlue
}
func (e Color) IsRGB() bool {
	return e.tag == ColorTagRGB
}
func colorToHex(c Color) string {
	var result interface{}
	// DINGO_MATCH_START: c
	scrutinee := c
	switch scrutinee.tag {
	case ColorTagRed:
		// DINGO_PATTERN: Color_Red
		result = "#FF0000"
	case ColorTagGreen:
		// DINGO_PATTERN: Color_Green
		result = "#00FF00"
	case ColorTagBlue:
		// DINGO_PATTERN: Color_Blue
		result = "#0000FF"
	case ColorTagRGB{r, g, b}:
		// DINGO_PATTERN: Color_RGB{r, g, b}
		result = "#" + toHex(r) + toHex(g) + toHex(b)
	}
	panic("unreachable: match is exhaustive")
	return result
	// DINGO_MATCH_END

}
func toHex(n int) string {
	// Simplified hex conversion
	if n < 16 {
		return "0" + string(n)
	}
	return string(n)
}
func main() {
	red := Color_Red()
	custom := Color_RGB{r: 128, g: 64, b: 32}

	println("Red:", colorToHex(red))
	println("Custom:", colorToHex(custom))
}
