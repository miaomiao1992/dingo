package main

type OptionTag uint8

const (
	OptionTagSome OptionTag = iota
	OptionTagNone
)

type Option struct {
	tag    OptionTag
	some *int
}

func Option_Some(arg0 int) Option {
	return Option{tag: OptionTagSome, some: &arg0}
}
func Option_None() Option {
	return Option{tag: OptionTagNone}
}
func (e Option) IsSome() bool {
	return e.tag == OptionTagSome
}
func (e Option) IsNone() bool {
	return e.tag == OptionTagNone
}

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag   ResultTag
	ok  *int
	err *error
}
func Result_Ok(arg0 int) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func Result_Err(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}

// Using 'where' keyword (Swift-style)
func analyzeValue(opt Option) string {
	var result interface{}

	scrutinee := opt
	switch scrutinee.tag {
	case OptionTagSome:
		x := *scrutinee.some

		if x > 100 {
			result = "large"

		} else if x > 10 {
			result = "medium"

		} else if x > 0 {
			result = "small"

		} else {
			result = "non-positive"
		}
	case OptionTagNone:

		result = "none"
	}
	panic("unreachable: match is exhaustive")
	return result

}

// Simple pattern with where guards (NOT nested)
func processResult(result Result) string {
	var result2 interface{}

	scrutinee2 := result
	switch scrutinee2.tag {
	case ResultTagOk:
		val := *scrutinee2.ok

		if val > 100 {
			result2 = "large value"

		} else if val > 0 {
			result2 = "positive value"

		} else {
			result2 = "non-positive value"
		}
	case ResultTagErr:

		result2 = "error"
	}
	panic("unreachable: match is exhaustive")
	return result2

}

// Guard fallthrough demonstration
func categorize(opt Option) string {
	var result3 interface{}

	scrutinee3 := opt
	switch scrutinee3.tag {
	case OptionTagSome:
		x := *scrutinee3.some

		if x%3 == 0 && x%5 == 0 {
			result3 = "fizzbuzz"

		} else if x%3 == 0 {
			result3 = "fizz"

		} else if x%5 == 0 {
			result3 = "buzz"

		} else {
			result3 = "number"
		}
	case OptionTagNone:

		result3 = "empty"
	}
	panic("unreachable: match is exhaustive")
	return result3

}
func main() {
	println(analyzeValue(Option_Some(150)))
	println(processResult(Result_Ok(42)))
	println(categorize(Option_Some(15)))
}
