package main

type OptionTag uint8

const (
	OptionTagSome OptionTag = iota
	OptionTagNone
)

type Option struct {
	tag  OptionTag
	some *int
}

func OptionSome(arg0 int) Option {
	return Option{tag: OptionTagSome, some: &arg0}
}
func OptionNone() Option {
	return Option{tag: OptionTagNone}
}
func (e Option) IsSome() bool {
	return e.tag == OptionTagSome
}
func (e Option) IsNone() bool {
	return e.tag == OptionTagNone
}

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag ResultTag
	ok  *int
	err *error
}
func ResultOk(arg0 int) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func ResultErr(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}

// Using 'where' keyword (Swift-style)
func analyzeValue(opt Option) string {
	var result interface{}

	scrutinee := opt
	switch scrutinee.tag {
	case OptionSomeTag:
		x := *scrutinee.optionsome

		if x > 100 {
			result = "large"

		} else if x > 10 {
			result = "medium"

		} else if x > 0 {
			result = "small"

		} else {
			result = "non-positive"
		}
	}
	panic("unreachable: match is exhaustive")
	return result

}

// Simple pattern with where guards (NOT nested)
func processResult(result Result) string {
	var result2 interface{}

	scrutinee2 := result
	switch scrutinee2.tag {
	case ResultOkTag:
		val := *scrutinee2.resultok

		if val > 100 {
			result2 = "large value"

		} else if val > 0 {
			result2 = "positive value"

		} else {
			result2 = "non-positive value"
		}
	case ResultErrTag:

		result2 = "error"
	}
	panic("unreachable: match is exhaustive")
	return result2

}

// Guard fallthrough demonstration
func categorize(opt Option) string {
	var result3 interface{}

	scrutinee3 := opt
	switch scrutinee3.tag {
	case OptionSomeTag:
		x := *scrutinee3.optionsome

		if x%3 == 0 && x%5 == 0 {
			result3 = "fizzbuzz"

		} else if x%3 == 0 {
			result3 = "fizz"

		} else if x%5 == 0 {
			result3 = "buzz"

		} else {
			result3 = "number"
		}
	}
	panic("unreachable: match is exhaustive")
	return result3

}
func main() {
	println(analyzeValue(OptionSome(150)))
	println(processResult(ResultOk(42)))
	println(categorize(OptionSome(15)))
}
