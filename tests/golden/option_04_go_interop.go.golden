package main

// Test: Option type interoperating with Go nil pointers
// Feature: Option type + Go interop
// Complexity: intermediate

// dingo:n:0
type OptionTag uint8

const (
	OptionTagSome OptionTag = iota
	OptionTagNone
)

type Option struct {
	tag  OptionTag
	some *string
}

func OptionSome(arg0 string) Option {
	return Option{tag: OptionTagSome, some: &arg0}
}
func OptionNone() Option {
	return Option{tag: OptionTagNone}
}
func (e Option) IsSome() bool {
	return e.tag == OptionTagSome
}
func (e Option) IsNone() bool {
	return e.tag == OptionTagNone
}
func (o Option) Map(fn func(string) string) Option {
	switch o.tag {
	case OptionTagSome:
		if o.some != nil {
			return OptionSome(fn(*o.some))
		}
	case OptionTagNone:
		return o
	}
	panic("invalid Option state")
}
func (o Option) AndThen(fn func(string) Option) Option {
	switch o.tag {
	case OptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case OptionTagNone:
		return o
	}
	panic("invalid Option state")
}
func (o Option) Unwrap() string {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func findInMap(m map[string]string, key string) Option {
	val, exists := m[key]
	if exists {
		return OptionSome(val)
	}
	return OptionNone()
}
func getOrDefault(opt Option, defaultVal string) string {
	if opt.IsSome() {
		return *opt.some
	}
	return defaultVal
}
func main() {
	data := map[string]string{"name": "Alice"}
	name := findInMap(data, "name")
	age := findInMap(data, "age")

	println("Name:", getOrDefault(name, "Unknown"))
	println("Age:", getOrDefault(age, "N/A"))
}
