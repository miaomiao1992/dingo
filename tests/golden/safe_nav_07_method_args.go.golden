package main

// Test: Method calls with arguments using safe navigation operator
// Feature: Safe Navigation (?.) - Method Arguments
// Complexity: intermediate

type UserOption_Tag int

const (
	UserOption_Tag_Some UserOption_Tag = iota
	UserOption_Tag_None
)

type UserOption struct {
	tag  UserOption_Tag
	some *User
}

func UserOption_Some(value User) UserOption {
	return UserOption{tag: UserOption_Tag_Some, some: &value}
}

func UserOption_None() UserOption {
	return UserOption{tag: UserOption_Tag_None, some: nil}
}

func (o UserOption) IsSome() bool {
	return o.tag == UserOption_Tag_Some
}

func (o UserOption) IsNone() bool {
	return o.tag == UserOption_Tag_None
}

func (o UserOption) Unwrap() User {
	if o.IsNone() {
		panic("called Unwrap on None")
	}
	return *o.some
}

type StringOption_Tag int

const (
	StringOption_Tag_Some StringOption_Tag = iota
	StringOption_Tag_None
)

type StringOption struct {
	tag  StringOption_Tag
	some *string
}

func StringOption_Some(value string) StringOption {
	return StringOption{tag: StringOption_Tag_Some, some: &value}
}

func StringOption_None() StringOption {
	return StringOption{tag: StringOption_Tag_None, some: nil}
}

func (o StringOption) IsSome() bool {
	return o.tag == StringOption_Tag_Some
}

func (o StringOption) IsNone() bool {
	return o.tag == StringOption_Tag_None
}

func (o StringOption) Unwrap() string {
	if o.IsNone() {
		panic("called Unwrap on None")
	}
	return *o.some
}

type IntOption_Tag int

const (
	IntOption_Tag_Some IntOption_Tag = iota
	IntOption_Tag_None
)

type IntOption struct {
	tag  IntOption_Tag
	some *int
}

func IntOption_Some(value int) IntOption {
	return IntOption{tag: IntOption_Tag_Some, some: &value}
}

func IntOption_None() IntOption {
	return IntOption{tag: IntOption_Tag_None, some: nil}
}

func (o IntOption) IsSome() bool {
	return o.tag == IntOption_Tag_Some
}

func (o IntOption) IsNone() bool {
	return o.tag == IntOption_Tag_None
}

func (o IntOption) Unwrap() int {
	if o.IsNone() {
		panic("called Unwrap on None")
	}
	return *o.some
}

type User struct {
	name string
}

func (u User) format(prefix string, suffix string) StringOption {
	result := prefix + u.name + suffix
	return StringOption_Some(result)
}

func (u User) process(count int, flag bool, msg string) IntOption {
	if flag {
		return IntOption_Some(count * 2)
	}
	return IntOption_None()
}

func (u User) transform(data string) StringOption {
	return StringOption_Some(data + ":" + u.name)
}

func getUser(id int) UserOption {
	if id > 0 {
		return UserOption_Some(User{name: "Alice"})
	}
	return UserOption_None()
}

func getData() string {
	return "payload"
}

func (u User) getName() StringOption {
	return StringOption_Some(u.name)
}

func main() {
	user := getUser(1)

	// Method with two string arguments
	formatted := func() StringOption {
		if user.IsNone() {
			return StringOption_None()
		}
		_user := user.Unwrap()

		return _user.format("Hello ", "!")
	}()
	println(formatted)

	// Method with multiple argument types
	result := func() IntOption {
		if user.IsNone() {
			return IntOption_None()
		}
		_user := user.Unwrap()

		return _user.process(42, true, "test")
	}()
	println(result)

	// Method with function call as argument
	transformed := func() StringOption {
		if user.IsNone() {
			return StringOption_None()
		}
		_user := user.Unwrap()

		return _user.transform(getData())
	}()
	println(transformed)

	// Zero arguments
	name := func() StringOption {
		if user.IsNone() {
			return StringOption_None()
		}
		_user := user.Unwrap()

		return _user.getName()
	}()
	println(name)
}
