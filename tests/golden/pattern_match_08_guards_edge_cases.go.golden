package main

type ValueTag uint8

const (
	ValueTagSmall ValueTag = iota
	ValueTagMedium
	ValueTagLarge
)

type Value struct {
	tag    ValueTag
	small  *int
	medium *int
	large  *int
}

func ValueSmall(arg0 int) Value {
	return Value{tag: ValueTagSmall, small: &arg0}
}
func ValueMedium(arg0 int) Value {
	return Value{tag: ValueTagMedium, medium: &arg0}
}
func ValueLarge(arg0 int) Value {
	return Value{tag: ValueTagLarge, large: &arg0}
}
func (e Value) IsSmall() bool {
	return e.tag == ValueTagSmall
}
func (e Value) IsMedium() bool {
	return e.tag == ValueTagMedium
}
func (e Value) IsLarge() bool {
	return e.tag == ValueTagLarge
}

// All patterns have guards (requires fallback wildcard)
func classify(val Value) string {
	var result interface{}

	scrutinee := val
	switch scrutinee.tag {
	case ValueTagSmall:
		x := *scrutinee.small

		if x > 10 {
			result = "actually medium"
		}
	case ValueTagMedium:
		x := *scrutinee.medium

		if x > 100 {
			result = "actually large"
		}
	case ValueTagLarge:
		x := *scrutinee.large

		if x > 1000 {
			result = "actually huge"
		}
	default:

		result = "normal range"
	}
	panic("unreachable: match is exhaustive")
	return result

}

// Wildcard pattern with guard
func filterPositive(val Value) string {
	var result2 interface{}

	scrutinee2 := val
	switch scrutinee2.tag {
	case ValueTagSmall:
		x := *scrutinee2.small

		if x > 0 {
			result2 = "positive small"
		}
	case ValueTagMedium:
		x := *scrutinee2.medium

		if x > 0 {
			result2 = "positive medium"
		}
	case ValueTagLarge:
		x := *scrutinee2.large

		if x > 0 {
			result2 = "positive large"
		}
	default:

		result2 = "non-positive or zero"
	}
	panic("unreachable: match is exhaustive")
	return result2

}

// Many guarded arms (performance test)
func granularClassify(val Value) string {
	var result3 interface{}

	scrutinee3 := val
	switch scrutinee3.tag {
	case ValueTagSmall:
		x := *scrutinee3.small

		if x == 1 {
			result3 = "one"

		} else if x == 2 {
			result3 = "two"

		} else if x == 3 {
			result3 = "three"

		} else if x == 4 {
			result3 = "four"

		} else if x == 5 {
			result3 = "five"

		} else if x > 5 && x < 10 {
			result3 = "five to ten"

		} else {
			result3 = "small other"
		}
	case ValueTagMedium:
		x := *scrutinee3.medium

		if x < 50 {
			result3 = "lower medium"

		} else if x >= 50 && x < 100 {
			result3 = "mid medium"

		} else {
			result3 = "upper medium"
		}
	case ValueTagLarge:

		result3 = "large"
	}
	panic("unreachable: match is exhaustive")
	return result3

}

// Guard with constant condition (optimization test)
func alwaysMatch(val Value) string {
	var result4 interface{}

	scrutinee4 := val
	switch scrutinee4.tag {
	case ValueTagSmall:

		if true {
			result4 = "small"
		}
	case ValueTagMedium:

		if 1 > 0 {
			result4 = "medium"
		}
	case ValueTagLarge:

		result4 = "large"
	}
	panic("unreachable: match is exhaustive")
	return result4

}

// Guard with side effects (not recommended but valid)
func countMatches(val Value) string {
	var count int = 0
	var result5 interface{}

	scrutinee5 := val
	switch scrutinee5.tag {
	case ValueTagSmall:
		x := *scrutinee5.small

		if increment(&count) && x > 0 {
			result5 = "small positive"
		}
	case ValueTagMedium:
		x := *scrutinee5.medium

		if increment(&count) && x > 0 {
			result5 = "medium positive"
		}
	case ValueTagLarge:
		x := *scrutinee5.large

		if increment(&count) && x > 0 {
			result5 = "large positive"
		}
	default:

		result5 = "other"
	}
	panic("unreachable: match is exhaustive")
	return result5

}
func increment(p *int) bool {
	*p++
	return true
}
func main() {
	println(classify(Value_Small(15)))
	println(filterPositive(Value_Medium(-5)))
	println(granularClassify(Value_Small(3)))
	println(alwaysMatch(Value_Medium(42)))
}
