package main

type ValueTag uint8

const (
	ValueTag_Small ValueTag = iota
	ValueTag_Medium
	ValueTag_Large
)

type Value struct {
	tag      ValueTag
	small_0  *int
	medium_0 *int
	large_0  *int
}

func Value_Small(arg0 int) Value {
	return Value{tag: ValueTag_Small, small_0: &arg0}
}
func Value_Medium(arg0 int) Value {
	return Value{tag: ValueTag_Medium, medium_0: &arg0}
}
func Value_Large(arg0 int) Value {
	return Value{tag: ValueTag_Large, large_0: &arg0}
}
func (e Value) IsSmall() bool {
	return e.tag == ValueTag_Small
}
func (e Value) IsMedium() bool {
	return e.tag == ValueTag_Medium
}
func (e Value) IsLarge() bool {
	return e.tag == ValueTag_Large
}

// All patterns have guards (requires fallback wildcard)
func classify(val Value) string {

	__match_0 := val
	switch __match_0.tag {
	case ValueTag_Small:

		x := __match_0.value_small_0
		if x > 10 {
			"actually medium"
		}
	case ValueTag_Medium:

		x := __match_0.value_medium_0
		if x > 100 {
			"actually large"
		}
	case ValueTag_Large:

		x := __match_0.value_large_0
		if x > 1000 {
			"actually huge"
		}
	default:

		"normal range"
	}

}

// Wildcard pattern with guard
func filterPositive(val Value) string {

	__match_1 := val
	switch __match_1.tag {
	case ValueTag_Small:

		x := __match_1.value_small_0
		if x > 0 {
			"positive small"
		}
	case ValueTag_Medium:

		x := __match_1.value_medium_0
		if x > 0 {
			"positive medium"
		}
	case ValueTag_Large:

		x := __match_1.value_large_0
		if x > 0 {
			"positive large"
		}
	default:

		"non-positive or zero"
	}

}

// Many guarded arms (performance test)
func granularClassify(val Value) string {

	__match_2 := val
	switch __match_2.tag {
	case ValueTag_Small:

		x := __match_2.value_small_0
		if x == 1 {
			"one"
		}
	case ValueTag_Small:

		x := __match_2.value_small_0
		if x == 2 {
			"two"
		}
	case ValueTag_Small:

		x := __match_2.value_small_0
		if x == 3 {
			"three"
		}
	case ValueTag_Small:

		x := __match_2.value_small_0
		if x == 4 {
			"four"
		}
	case ValueTag_Small:

		x := __match_2.value_small_0
		if x == 5 {
			"five"
		}
	case ValueTag_Small:

		x := __match_2.value_small_0
		if x > 5 && x < 10 {
			"five to ten"
		}
	case ValueTag_Small:

		_ := __match_2.value_small_0
		"small other"
	case ValueTag_Medium:

		x := __match_2.value_medium_0
		if x < 50 {
			"lower medium"
		}
	case ValueTag_Medium:

		x := __match_2.value_medium_0
		if x >= 50 && x < 100 {
			"mid medium"
		}
	case ValueTag_Medium:

		_ := __match_2.value_medium_0
		"upper medium"
	case ValueTag_Large:

		_ := __match_2.value_large_0
		"large"
	}

}

// Guard with constant condition (optimization test)
func alwaysMatch(val Value) string {

	__match_3 := val
	switch __match_3.tag {
	case ValueTag_Small:

		_ := __match_3.value_small_0
		if true {
			"small"
		}
	case ValueTag_Medium:

		_ := __match_3.value_medium_0
		if 1 > 0 {
			"medium"
		}
	case ValueTag_Large:

		_ := __match_3.value_large_0
		"large"
	}

}

// Guard with side effects (not recommended but valid)
func countMatches(val Value) string {
	var count int = 0

	__match_4 := val
	switch __match_4.tag {
	case ValueTag_Small:

		x := __match_4.value_small_0
		if increment(&count) && x > 0 {
			"small positive"
		}
	case ValueTag_Medium:

		x := __match_4.value_medium_0
		if increment(&count) && x > 0 {
			"medium positive"
		}
	case ValueTag_Large:

		x := __match_4.value_large_0
		if increment(&count) && x > 0 {
			"large positive"
		}
	default:

		"other"
	}

}
func increment(p *int) bool {
	*p++
	return true
}
func main() {
	println(classify(Value_Small(15)))
	println(filterPositive(Value_Medium(-5)))
	println(granularClassify(Value_Small(3)))
	println(alwaysMatch(Value_Medium(42)))
}
