package main

import (
	"fmt"
)

type OptionTag uint8

const (
	OptionTagSome OptionTag = iota
	OptionTagNone
)

type Option_int struct {
	tag  OptionTag
	some *int
}

func Option_int_Some(arg0 int) Option_int {
	return Option_int{tag: OptionTagSome, some: &arg0}
}
func Option_int_None() Option_int {
	return Option_int{tag: OptionTagNone}
}
func (o Option_int) IsSome() bool {
	return o.tag == OptionTagSome
}
func (o Option_int) IsNone() bool {
	return o.tag == OptionTagNone
}
func (o Option_int) Unwrap() int {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func (o Option_int) UnwrapOr(defaultValue int) int {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return defaultValue
}
func (o Option_int) UnwrapOrElse(fn func() int) int {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return fn()
}
func (o Option_int) Map(fn func(int) interface{}) Option_int {
	if o.tag == OptionTagNone {
		return o
	}
	mapped := fn(*o.some)
	result := mapped.(int)
	return Option_int{tag: OptionTagSome, some: &result}
}
func (o Option_int) AndThen(fn func(int) Option_int) Option_int {
	if o.tag == OptionTagNone {
		return o
	}
	return fn(*o.some)
}
func (o Option_int) Filter(predicate func(int) bool) Option_int {
	if o.tag == OptionTagNone {
		return o
	}
	if predicate(*o.some) {
		return o
	}
	return Option_int{tag: OptionTagNone}
}

type Option_string struct {
	tag  OptionTag
	some *string
}
func Option_string_Some(arg0 string) Option_string {
	return Option_string{tag: OptionTagSome, some: &arg0}
}
func Option_string_None() Option_string {
	return Option_string{tag: OptionTagNone}
}
func (o Option_string) IsSome() bool {
	return o.tag == OptionTagSome
}
func (o Option_string) IsNone() bool {
	return o.tag == OptionTagNone
}
func (o Option_string) Unwrap() string {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func (o Option_string) UnwrapOr(defaultValue string) string {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return defaultValue
}
func (o Option_string) UnwrapOrElse(fn func() string) string {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return fn()
}
func (o Option_string) Map(fn func(string) interface{}) Option_string {
	if o.tag == OptionTagNone {
		return o
	}
	mapped := fn(*o.some)
	result := mapped.(string)
	return Option_string{tag: OptionTagSome, some: &result}
}
func (o Option_string) AndThen(fn func(string) Option_string) Option_string {
	if o.tag == OptionTagNone {
		return o
	}
	return fn(*o.some)
}
func (o Option_string) Filter(predicate func(string) bool) Option_string {
	if o.tag == OptionTagNone {
		return o
	}
	if predicate(*o.some) {
		return o
	}
	return Option_string{tag: OptionTagNone}
}

type Option_float64 struct {
	tag  OptionTag
	some *float64
}
func Option_float64_Some(arg0 float64) Option_float64 {
	return Option_float64{tag: OptionTagSome, some: &arg0}
}
func Option_float64_None() Option_float64 {
	return Option_float64{tag: OptionTagNone}
}
func (o Option_float64) IsSome() bool {
	return o.tag == OptionTagSome
}
func (o Option_float64) IsNone() bool {
	return o.tag == OptionTagNone
}
func (o Option_float64) Unwrap() float64 {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func (o Option_float64) UnwrapOr(defaultValue float64) float64 {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return defaultValue
}
func (o Option_float64) UnwrapOrElse(fn func() float64) float64 {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return fn()
}
func (o Option_float64) Map(fn func(float64) interface{}) Option_float64 {
	if o.tag == OptionTagNone {
		return o
	}
	mapped := fn(*o.some)
	result := mapped.(float64)
	return Option_float64{tag: OptionTagSome, some: &result}
}
func (o Option_float64) AndThen(fn func(float64) Option_float64) Option_float64 {
	if o.tag == OptionTagNone {
		return o
	}
	return fn(*o.some)
}
func (o Option_float64) Filter(predicate func(float64) bool) Option_float64 {
	if o.tag == OptionTagNone {
		return o
	}
	if predicate(*o.some) {
		return o
	}
	return Option_float64{tag: OptionTagNone}
}

type Option_bool struct {
	tag  OptionTag
	some *bool
}
func Option_bool_Some(arg0 bool) Option_bool {
	return Option_bool{tag: OptionTagSome, some: &arg0}
}
func Option_bool_None() Option_bool {
	return Option_bool{tag: OptionTagNone}
}
func (o Option_bool) IsSome() bool {
	return o.tag == OptionTagSome
}
func (o Option_bool) IsNone() bool {
	return o.tag == OptionTagNone
}
func (o Option_bool) Unwrap() bool {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func (o Option_bool) UnwrapOr(defaultValue bool) bool {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return defaultValue
}
func (o Option_bool) UnwrapOrElse(fn func() bool) bool {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return fn()
}
func (o Option_bool) Map(fn func(bool) interface{}) Option_bool {
	if o.tag == OptionTagNone {
		return o
	}
	mapped := fn(*o.some)
	result := mapped.(bool)
	return Option_bool{tag: OptionTagSome, some: &result}
}
func (o Option_bool) AndThen(fn func(bool) Option_bool) Option_bool {
	if o.tag == OptionTagNone {
		return o
	}
	return fn(*o.some)
}
func (o Option_bool) Filter(predicate func(bool) bool) Option_bool {
	if o.tag == OptionTagNone {
		return o
	}
	if predicate(*o.some) {
		return o
	}
	return Option_bool{tag: OptionTagNone}
}

type Option_interface struct {
	tag  OptionTag
	some *interface{}
}
func Option_interface_Some(arg0 interface{}) Option_interface {
	return Option_interface{tag: OptionTagSome, some: &arg0}
}
func Option_interface_None() Option_interface {
	return Option_interface{tag: OptionTagNone}
}
func (o Option_interface) IsSome() bool {
	return o.tag == OptionTagSome
}
func (o Option_interface) IsNone() bool {
	return o.tag == OptionTagNone
}
func (o Option_interface) Unwrap() interface{} {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func (o Option_interface) UnwrapOr(defaultValue interface{}) interface{} {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return defaultValue
}
func (o Option_interface) UnwrapOrElse(fn func() interface{}) interface{} {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return fn()
}
func (o Option_interface) Map(fn func(interface{}) interface{}) Option_interface {
	if o.tag == OptionTagNone {
		return o
	}
	mapped := fn(*o.some)
	result := mapped.(interface{})
	return Option_interface{tag: OptionTagSome, some: &result}
}
func (o Option_interface) AndThen(fn func(interface{}) Option_interface) Option_interface {
	if o.tag == OptionTagNone {
		return o
	}
	return fn(*o.some)
}
func (o Option_interface) Filter(predicate func(interface{}) bool) Option_interface {
	if o.tag == OptionTagNone {
		return o
	}
	if predicate(*o.some) {
		return o
	}
	return Option_interface{tag: OptionTagNone}
}
func main() {

	intOpt := Some(42)
	strOpt := Some("hello")
	floatOpt := Some(3.14)
	boolOpt := Some(true)

	x := 100
	varOpt := Some(x)

	if intOpt.IsSome() {
		fmt.Printf("intOpt: %d\n", intOpt.Unwrap())
	}

	if strOpt.IsSome() {
		fmt.Printf("strOpt: %s\n", strOpt.Unwrap())
	}

	if floatOpt.IsSome() {
		fmt.Printf("floatOpt: %.2f\n", floatOpt.Unwrap())
	}

	if boolOpt.IsSome() {
		fmt.Printf("boolOpt: %t\n", boolOpt.Unwrap())
	}

	if varOpt.IsSome() {
		fmt.Printf("varOpt: %d\n", varOpt.Unwrap())
	}
}
