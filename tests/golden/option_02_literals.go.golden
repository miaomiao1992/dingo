package main

import (
	"fmt"
)

type OptionTag uint8

const (
	OptionTag_Some OptionTag = iota
	OptionTag_None
)

type Option_int struct {
	tag    OptionTag
	some_0 *int
}

func Option_int_Some(arg0 int) Option_int {
	return Option_int{tag: OptionTag_Some, some_0: &arg0}
}
func Option_int_None() Option_int {
	return Option_int{tag: OptionTag_None}
}
func (o Option_int) IsSome() bool {
	return o.tag == OptionTag_Some
}
func (o Option_int) IsNone() bool {
	return o.tag == OptionTag_None
}
func (o Option_int) Unwrap() int {
	if o.tag != OptionTag_Some {
		panic("called Unwrap on None")
	}
	return *o.some_0
}
func (o Option_int) UnwrapOr(defaultValue int) int {
	if o.tag == OptionTag_Some {
		return *o.some_0
	}
	return defaultValue
}
func (o Option_int) UnwrapOrElse(fn func() int) int {
	if o.tag == OptionTag_Some {
		return *o.some_0
	}
	return fn()
}
func (o Option_int) Map(fn func(int) interface{}) Option_int {
	if o.tag == OptionTag_None {
		return o
	}
	mapped := fn(*o.some_0)
	result := mapped.(int)
	return Option_int{tag: OptionTag_Some, some_0: &result}
}
func (o Option_int) AndThen(fn func(int) Option_int) Option_int {
	if o.tag == OptionTag_None {
		return o
	}
	return fn(*o.some_0)
}
func (o Option_int) Filter(predicate func(int) bool) Option_int {
	if o.tag == OptionTag_None {
		return o
	}
	if predicate(*o.some_0) {
		return o
	}
	return Option_int{tag: OptionTag_None}
}

type Option_string struct {
	tag    OptionTag
	some_0 *string
}
func Option_string_Some(arg0 string) Option_string {
	return Option_string{tag: OptionTag_Some, some_0: &arg0}
}
func Option_string_None() Option_string {
	return Option_string{tag: OptionTag_None}
}
func (o Option_string) IsSome() bool {
	return o.tag == OptionTag_Some
}
func (o Option_string) IsNone() bool {
	return o.tag == OptionTag_None
}
func (o Option_string) Unwrap() string {
	if o.tag != OptionTag_Some {
		panic("called Unwrap on None")
	}
	return *o.some_0
}
func (o Option_string) UnwrapOr(defaultValue string) string {
	if o.tag == OptionTag_Some {
		return *o.some_0
	}
	return defaultValue
}
func (o Option_string) UnwrapOrElse(fn func() string) string {
	if o.tag == OptionTag_Some {
		return *o.some_0
	}
	return fn()
}
func (o Option_string) Map(fn func(string) interface{}) Option_string {
	if o.tag == OptionTag_None {
		return o
	}
	mapped := fn(*o.some_0)
	result := mapped.(string)
	return Option_string{tag: OptionTag_Some, some_0: &result}
}
func (o Option_string) AndThen(fn func(string) Option_string) Option_string {
	if o.tag == OptionTag_None {
		return o
	}
	return fn(*o.some_0)
}
func (o Option_string) Filter(predicate func(string) bool) Option_string {
	if o.tag == OptionTag_None {
		return o
	}
	if predicate(*o.some_0) {
		return o
	}
	return Option_string{tag: OptionTag_None}
}

type Option_float64 struct {
	tag    OptionTag
	some_0 *float64
}
func Option_float64_Some(arg0 float64) Option_float64 {
	return Option_float64{tag: OptionTag_Some, some_0: &arg0}
}
func Option_float64_None() Option_float64 {
	return Option_float64{tag: OptionTag_None}
}
func (o Option_float64) IsSome() bool {
	return o.tag == OptionTag_Some
}
func (o Option_float64) IsNone() bool {
	return o.tag == OptionTag_None
}
func (o Option_float64) Unwrap() float64 {
	if o.tag != OptionTag_Some {
		panic("called Unwrap on None")
	}
	return *o.some_0
}
func (o Option_float64) UnwrapOr(defaultValue float64) float64 {
	if o.tag == OptionTag_Some {
		return *o.some_0
	}
	return defaultValue
}
func (o Option_float64) UnwrapOrElse(fn func() float64) float64 {
	if o.tag == OptionTag_Some {
		return *o.some_0
	}
	return fn()
}
func (o Option_float64) Map(fn func(float64) interface{}) Option_float64 {
	if o.tag == OptionTag_None {
		return o
	}
	mapped := fn(*o.some_0)
	result := mapped.(float64)
	return Option_float64{tag: OptionTag_Some, some_0: &result}
}
func (o Option_float64) AndThen(fn func(float64) Option_float64) Option_float64 {
	if o.tag == OptionTag_None {
		return o
	}
	return fn(*o.some_0)
}
func (o Option_float64) Filter(predicate func(float64) bool) Option_float64 {
	if o.tag == OptionTag_None {
		return o
	}
	if predicate(*o.some_0) {
		return o
	}
	return Option_float64{tag: OptionTag_None}
}

type Option_bool struct {
	tag    OptionTag
	some_0 *bool
}
func Option_bool_Some(arg0 bool) Option_bool {
	return Option_bool{tag: OptionTag_Some, some_0: &arg0}
}
func Option_bool_None() Option_bool {
	return Option_bool{tag: OptionTag_None}
}
func (o Option_bool) IsSome() bool {
	return o.tag == OptionTag_Some
}
func (o Option_bool) IsNone() bool {
	return o.tag == OptionTag_None
}
func (o Option_bool) Unwrap() bool {
	if o.tag != OptionTag_Some {
		panic("called Unwrap on None")
	}
	return *o.some_0
}
func (o Option_bool) UnwrapOr(defaultValue bool) bool {
	if o.tag == OptionTag_Some {
		return *o.some_0
	}
	return defaultValue
}
func (o Option_bool) UnwrapOrElse(fn func() bool) bool {
	if o.tag == OptionTag_Some {
		return *o.some_0
	}
	return fn()
}
func (o Option_bool) Map(fn func(bool) interface{}) Option_bool {
	if o.tag == OptionTag_None {
		return o
	}
	mapped := fn(*o.some_0)
	result := mapped.(bool)
	return Option_bool{tag: OptionTag_Some, some_0: &result}
}
func (o Option_bool) AndThen(fn func(bool) Option_bool) Option_bool {
	if o.tag == OptionTag_None {
		return o
	}
	return fn(*o.some_0)
}
func (o Option_bool) Filter(predicate func(bool) bool) Option_bool {
	if o.tag == OptionTag_None {
		return o
	}
	if predicate(*o.some_0) {
		return o
	}
	return Option_bool{tag: OptionTag_None}
}

type Option_any struct {
	tag    OptionTag
	some_0 *interface{}
}
func Option_any_Some(arg0 interface{}) Option_any {
	return Option_any{tag: OptionTag_Some, some_0: &arg0}
}
func Option_any_None() Option_any {
	return Option_any{tag: OptionTag_None}
}
func (o Option_any) IsSome() bool {
	return o.tag == OptionTag_Some
}
func (o Option_any) IsNone() bool {
	return o.tag == OptionTag_None
}
func (o Option_any) Unwrap() interface{} {
	if o.tag != OptionTag_Some {
		panic("called Unwrap on None")
	}
	return *o.some_0
}
func (o Option_any) UnwrapOr(defaultValue interface{}) interface{} {
	if o.tag == OptionTag_Some {
		return *o.some_0
	}
	return defaultValue
}
func (o Option_any) UnwrapOrElse(fn func() interface{}) interface{} {
	if o.tag == OptionTag_Some {
		return *o.some_0
	}
	return fn()
}
func (o Option_any) Map(fn func(interface{}) interface{}) Option_any {
	if o.tag == OptionTag_None {
		return o
	}
	mapped := fn(*o.some_0)
	result := mapped.(interface{})
	return Option_any{tag: OptionTag_Some, some_0: &result}
}
func (o Option_any) AndThen(fn func(interface{}) Option_any) Option_any {
	if o.tag == OptionTag_None {
		return o
	}
	return fn(*o.some_0)
}
func (o Option_any) Filter(predicate func(interface{}) bool) Option_any {
	if o.tag == OptionTag_None {
		return o
	}
	if predicate(*o.some_0) {
		return o
	}
	return Option_any{tag: OptionTag_None}
}
func main() {

	intOpt := Some(42)
	strOpt := Some("hello")
	floatOpt := Some(3.14)
	boolOpt := Some(true)

	x := 100
	varOpt := Some(x)

	if intOpt.IsSome() {
		fmt.Printf("intOpt: %d\n", intOpt.Unwrap())
	}

	if strOpt.IsSome() {
		fmt.Printf("strOpt: %s\n", strOpt.Unwrap())
	}

	if floatOpt.IsSome() {
		fmt.Printf("floatOpt: %.2f\n", floatOpt.Unwrap())
	}

	if boolOpt.IsSome() {
		fmt.Printf("boolOpt: %t\n", boolOpt.Unwrap())
	}

	if varOpt.IsSome() {
		fmt.Printf("varOpt: %d\n", varOpt.Unwrap())
	}
}
