package main

import (
"fmt"
)

type OptionTag uint8
const (
	OptionTagSome OptionTag = iota
	OptionTagNone
)
type OptionInt struct {
	tag  OptionTag
	some *int
}
func OptionIntSome(arg0 int) OptionInt {
	return OptionInt{tag: OptionTagSome, some: &arg0}
}
func OptionIntNone() OptionInt {
	return OptionInt{tag: OptionTagNone}
}
func (o OptionInt) IsSome() bool {
	return o.tag == OptionTagSome
}
func (o OptionInt) IsNone() bool {
	return o.tag == OptionTagNone
}
func (o OptionInt) Unwrap() int {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func (o OptionInt) UnwrapOr(defaultValue int) int {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return defaultValue
}
func (o OptionInt) UnwrapOrElse(fn func() int) int {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return fn()
}
func (o OptionInt) Map(fn func(int) interface{}) OptionInt {
	if o.tag == OptionTagNone {
		return o
	}
	mapped := fn(*o.some)
	result := mapped.(int)
	return OptionInt{tag: OptionTagSome, some: &result}
}
func (o OptionInt) AndThen(fn func(int) OptionInt) OptionInt {
	if o.tag == OptionTagNone {
		return o
	}
	return fn(*o.some)
}
func (o OptionInt) Filter(predicate func(int) bool) OptionInt {
	if o.tag == OptionTagNone {
		return o
	}
	if predicate(*o.some) {
		return o
	}
	return OptionInt{tag: OptionTagNone}
}
type OptionString struct {
	tag  OptionTag
	some *string
}
func OptionStringSome(arg0 string) OptionString {
	return OptionString{tag: OptionTagSome, some: &arg0}
}
func OptionStringNone() OptionString {
	return OptionString{tag: OptionTagNone}
}
func (o OptionString) IsSome() bool {
	return o.tag == OptionTagSome
}
func (o OptionString) IsNone() bool {
	return o.tag == OptionTagNone
}
func (o OptionString) Unwrap() string {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func (o OptionString) UnwrapOr(defaultValue string) string {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return defaultValue
}
func (o OptionString) UnwrapOrElse(fn func() string) string {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return fn()
}
func (o OptionString) Map(fn func(string) interface{}) OptionString {
	if o.tag == OptionTagNone {
		return o
	}
	mapped := fn(*o.some)
	result := mapped.(string)
	return OptionString{tag: OptionTagSome, some: &result}
}
func (o OptionString) AndThen(fn func(string) OptionString) OptionString {
	if o.tag == OptionTagNone {
		return o
	}
	return fn(*o.some)
}
func (o OptionString) Filter(predicate func(string) bool) OptionString {
	if o.tag == OptionTagNone {
		return o
	}
	if predicate(*o.some) {
		return o
	}
	return OptionString{tag: OptionTagNone}
}
type OptionFloat64 struct {
	tag  OptionTag
	some *float64
}
func OptionFloat64Some(arg0 float64) OptionFloat64 {
	return OptionFloat64{tag: OptionTagSome, some: &arg0}
}
func OptionFloat64None() OptionFloat64 {
	return OptionFloat64{tag: OptionTagNone}
}
func (o OptionFloat64) IsSome() bool {
	return o.tag == OptionTagSome
}
func (o OptionFloat64) IsNone() bool {
	return o.tag == OptionTagNone
}
func (o OptionFloat64) Unwrap() float64 {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func (o OptionFloat64) UnwrapOr(defaultValue float64) float64 {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return defaultValue
}
func (o OptionFloat64) UnwrapOrElse(fn func() float64) float64 {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return fn()
}
func (o OptionFloat64) Map(fn func(float64) interface{}) OptionFloat64 {
	if o.tag == OptionTagNone {
		return o
	}
	mapped := fn(*o.some)
	result := mapped.(float64)
	return OptionFloat64{tag: OptionTagSome, some: &result}
}
func (o OptionFloat64) AndThen(fn func(float64) OptionFloat64) OptionFloat64 {
	if o.tag == OptionTagNone {
		return o
	}
	return fn(*o.some)
}
func (o OptionFloat64) Filter(predicate func(float64) bool) OptionFloat64 {
	if o.tag == OptionTagNone {
		return o
	}
	if predicate(*o.some) {
		return o
	}
	return OptionFloat64{tag: OptionTagNone}
}
type OptionBool struct {
	tag  OptionTag
	some *bool
}
func OptionBoolSome(arg0 bool) OptionBool {
	return OptionBool{tag: OptionTagSome, some: &arg0}
}
func OptionBoolNone() OptionBool {
	return OptionBool{tag: OptionTagNone}
}
func (o OptionBool) IsSome() bool {
	return o.tag == OptionTagSome
}
func (o OptionBool) IsNone() bool {
	return o.tag == OptionTagNone
}
func (o OptionBool) Unwrap() bool {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func (o OptionBool) UnwrapOr(defaultValue bool) bool {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return defaultValue
}
func (o OptionBool) UnwrapOrElse(fn func() bool) bool {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return fn()
}
func (o OptionBool) Map(fn func(bool) interface{}) OptionBool {
	if o.tag == OptionTagNone {
		return o
	}
	mapped := fn(*o.some)
	result := mapped.(bool)
	return OptionBool{tag: OptionTagSome, some: &result}
}
func (o OptionBool) AndThen(fn func(bool) OptionBool) OptionBool {
	if o.tag == OptionTagNone {
		return o
	}
	return fn(*o.some)
}
func (o OptionBool) Filter(predicate func(bool) bool) OptionBool {
	if o.tag == OptionTagNone {
		return o
	}
	if predicate(*o.some) {
		return o
	}
	return OptionBool{tag: OptionTagNone}
}
type OptionInterface{} struct {
	tag  OptionTag
	some *interface{}
}
func OptionInterface{}Some(arg0 interface{}) OptionInterface{} {
	return OptionInterface{}{tag: OptionTagSome, some: &arg0}
}
func OptionInterface{}None() OptionInterface{} {
	return OptionInterface{}{tag: OptionTagNone}
}
func (o OptionInterface{}) IsSome() bool {
	return o.tag == OptionTagSome
}
func (o OptionInterface{}) IsNone() bool {
	return o.tag == OptionTagNone
}
func (o OptionInterface{}) Unwrap() interface{} {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func (o OptionInterface{}) UnwrapOr(defaultValue interface{}) interface{} {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return defaultValue
}
func (o OptionInterface{}) UnwrapOrElse(fn func() interface{}) interface{} {
	if o.tag == OptionTagSome {
		return *o.some
	}
	return fn()
}
func (o OptionInterface{}) Map(fn func(interface{}) interface{}) OptionInterface{} {
	if o.tag == OptionTagNone {
		return o
	}
	mapped := fn(*o.some)
	result := mapped.(interface{})
	return OptionInterface{}{tag: OptionTagSome, some: &result}
}
func (o OptionInterface{}) AndThen(fn func(interface{}) OptionInterface{}) OptionInterface{} {
	if o.tag == OptionTagNone {
		return o
	}
	return fn(*o.some)
}
func (o OptionInterface{}) Filter(predicate func(interface{}) bool) OptionInterface{} {
	if o.tag == OptionTagNone {
		return o
	}
	if predicate(*o.some) {
		return o
	}
	return OptionInterface{}{tag: OptionTagNone}
}

func main() {

	intOpt := Some(42)
	strOpt := Some("hello")
	floatOpt := Some(3.14)
	boolOpt := Some(true)

	x := 100
	varOpt := Some(x)

	if intOpt.IsSome() {
		fmt.Printf("intOpt: %d\n", intOpt.Unwrap())
	}

	if strOpt.IsSome() {
		fmt.Printf("strOpt: %s\n", strOpt.Unwrap())
	}

	if floatOpt.IsSome() {
		fmt.Printf("floatOpt: %.2f\n", floatOpt.Unwrap())
	}

	if boolOpt.IsSome() {
		fmt.Printf("boolOpt: %t\n", boolOpt.Unwrap())
	}

	if varOpt.IsSome() {
		fmt.Printf("varOpt: %d\n", varOpt.Unwrap())
	}
}
