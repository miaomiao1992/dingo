package main

// Test: Null coalescing edge cases and special scenarios
// Feature: ?? operator edge cases
// Complexity: advanced

type StringOptionTag uint8

const (
	StringOptionTagSome StringOptionTag = iota
	StringOptionTagNone
)

type StringOption struct {
	tag  StringOptionTag
	some *string
}

func StringOption_Some(arg0 string) StringOption {
	return StringOption{tag: StringOptionTagSome, some: &arg0}
}
func StringOption_None() StringOption {
	return StringOption{tag: StringOptionTagNone}
}
func (e StringOption) IsSome() bool {
	return e.tag == StringOptionTagSome
}
func (e StringOption) IsNone() bool {
	return e.tag == StringOptionTagNone
}

type BoolOptionTag uint8

const (
	BoolOptionTagSome BoolOptionTag = iota
	BoolOptionTagNone
)

type BoolOption struct {
	tag  BoolOptionTag
	some *bool
}

func BoolOption_Some(arg0 bool) BoolOption {
	return BoolOption{tag: BoolOptionTagSome, some: &arg0}
}
func BoolOption_None() BoolOption {
	return BoolOption{tag: BoolOptionTagNone}
}
func (e BoolOption) IsSome() bool {
	return e.tag == BoolOptionTagSome
}
func (e BoolOption) IsNone() bool {
	return e.tag == BoolOptionTagNone
}

func main() {
	// Test 1: Empty string as fallback
	var name StringOption = StringOption_Some("")
	var display string
	if name.IsSome() {
		display = *name.some
	} else {
		display = "Default"
	}

	// Test 2: Zero value as fallback
	var zero BoolOption = BoolOption_Some(false)
	var result bool
	if zero.IsSome() {
		result = *zero.some
	} else {
		result = true
	}

	// Test 3: Nested parentheses
	var opt1 StringOption = StringOption_None()
	var opt2 StringOption = StringOption_Some("Found")
	var combined string
	__inner := func() string {
		if opt1.IsSome() {
			return *opt1.some
		}
		if opt2.IsSome() {
			return *opt2.some
		}
		return ""
	}()
	if __inner != "" {
		combined = __inner
	} else {
		combined = "Fallback"
	}

	// Test 4: ?? in boolean context
	var flag BoolOption = BoolOption_None()
	var enabled bool
	if flag.IsSome() {
		enabled = *flag.some
	} else {
		enabled = false
	}

	// Test 5: Multiple ?? in same expression (different vars)
	var first StringOption = StringOption_None()
	var second StringOption = StringOption_None()
	var a string
	if first.IsSome() {
		a = *first.some
	} else {
		a = "A"
	}
	var b string
	if second.IsSome() {
		b = *second.some
	} else {
		b = "B"
	}
	var concat = a + b

	// Test 6: ?? with method chain
	var text StringOption = StringOption_Some("hello")
	var upper = func() string {
		__safeNav := func() StringOption {
			if text.IsNone() {
				return StringOption_None()
			}
			_text := *text.some
			return _text.toUpper()
		}()
		if __safeNav.IsSome() {
			return *__safeNav.some
		}
		return "DEFAULT"
	}()

	println("Display:", display)
	println("Result:", result)
	println("Combined:", combined)
	println("Enabled:", enabled)
	println("Concat:", concat)
	println("Upper:", upper)
}

func (s StringOption) toUpper() StringOption {
	if s.IsNone() {
		return StringOption_None()
	}
	// Simplified uppercase
	return s
}
