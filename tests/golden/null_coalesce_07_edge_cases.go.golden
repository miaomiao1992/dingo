package main

type StringOptionTag uint8

const (
	StringOptionTagSome StringOptionTag = iota
	StringOptionTagNone
)

type StringOption struct {
	tag  StringOptionTag
	some *string
}

func StringOptionSome(arg0 string) StringOption {
	return StringOption{tag: StringOptionTagSome, some: &arg0}
}
func StringOptionNone() StringOption {
	return StringOption{tag: StringOptionTagNone}
}
func (e StringOption) IsSome() bool {
	return e.tag == StringOptionTagSome
}
func (e StringOption) IsNone() bool {
	return e.tag == StringOptionTagNone
}
func (o StringOption) Map(fn func(string) string) StringOption {
	switch o.tag {
	case StringOptionTagSome:
		if o.some != nil {
			return StringOptionSome(fn(*o.some))
		}
	case StringOptionTagNone:
		return o
	}
	panic("invalid StringOption state")
}
func (o StringOption) AndThen(fn func(string) StringOption) StringOption {
	switch o.tag {
	case StringOptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case StringOptionTagNone:
		return o
	}
	panic("invalid StringOption state")
}

type BoolOptionTag uint8

const (
	BoolOptionTagSome BoolOptionTag = iota
	BoolOptionTagNone
)

type BoolOption struct {
	tag  BoolOptionTag
	some *bool
}
func BoolOptionSome(arg0 bool) BoolOption {
	return BoolOption{tag: BoolOptionTagSome, some: &arg0}
}
func BoolOptionNone() BoolOption {
	return BoolOption{tag: BoolOptionTagNone}
}
func (e BoolOption) IsSome() bool {
	return e.tag == BoolOptionTagSome
}
func (e BoolOption) IsNone() bool {
	return e.tag == BoolOptionTagNone
}
func (o BoolOption) Map(fn func(bool) bool) BoolOption {
	switch o.tag {
	case BoolOptionTagSome:
		if o.some != nil {
			return BoolOptionSome(fn(*o.some))
		}
	case BoolOptionTagNone:
		return o
	}
	panic("invalid BoolOption state")
}
func (o BoolOption) AndThen(fn func(bool) BoolOption) BoolOption {
	switch o.tag {
	case BoolOptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case BoolOptionTagNone:
		return o
	}
	panic("invalid BoolOption state")
}
func main() {

	name := StringOptionSome("")
	display := func() __INFER__ {
		if name.IsSome() {
			return __UNWRAP__(name)
		}
		return "Default"
	}()

	zero := BoolOptionSome(false)
	result := func() __INFER__ {
		if zero.IsSome() {
			return __UNWRAP__(zero)
		}
		return true
	}()

	opt1 := StringOptionNone()
	opt2 := StringOptionSome("Found")
	intermediate := func() __INFER__ {
		if opt1.IsSome() {
			return __UNWRAP__(opt1)
		}
		return opt2
	}()
	combined := func() __INFER__ {
		if intermediate.IsSome() {
			return __UNWRAP__(intermediate)
		}
		return "Fallback"
	}()

	flag := BoolOptionNone()
	enabled := func() __INFER__ {
		if flag.IsSome() {
			return __UNWRAP__(flag)
		}
		return false
	}()

	first := StringOptionNone()
	second := StringOptionNone()
	a := func() __INFER__ {
		if first.IsSome() {
			return __UNWRAP__(first)
		}
		return "A"
	}()
	b := func() __INFER__ {
		if second.IsSome() {
			return __UNWRAP__(second)
		}
		return "B"
	}()
	concat := a + b

	text := StringOptionSome("hello")
	upperOpt := func() __INFER__ {
		if text.IsNone() {
			return __INFER___None()
		}
		text1 := text.Unwrap()
		return text1.toUpper()
	}()
	upper := func() __INFER__ {
		if upperOpt.IsSome() {
			return __UNWRAP__(upperOpt)
		}
		return "DEFAULT"
	}()

	println("Display:", display)
	println("Result:", result)
	println("Combined:", combined)
	println("Enabled:", enabled)
	println("Concat:", concat)
	println("Upper:", upper)
}
func (s StringOption) toUpper() StringOption {
	if s.IsNone() {
		return StringOptionNone()
	}

	return s
}
