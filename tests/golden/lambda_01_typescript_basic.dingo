package main

import "fmt"

// Test: Basic TypeScript arrow syntax lambdas
// Feature: Lambda functions (TypeScript style)
// Complexity: basic

type User struct {
	Name string
	Age  int
}

func main() {
	// Single param without parens (with explicit type)
	double := (x: int): int => x * 2
	result1 := double(5)

	// Single param with parens
	triple := (x: int): int => x * 3
	result2 := triple(5)

	// Multi-param
	add := (x: int, y: int): int => x + y
	result3 := add(10, 20)

	// With explicit types
	multiply := (x: int, y: int) => x * y
	result4 := multiply(4, 7)

	// In map/filter context (simulated with slice iteration)
	numbers := []int{1, 2, 3, 4, 5}
	var doubled []int
	for _, n := range numbers {
		transform := (x: int): int => x * 2
		doubled = append(doubled, transform(n))
	}

	// Lambda in function call
	apply := func(f func(int) int, val int) int {
		return f(val)
	}
	result5 := apply((x: int): int => x + 10, 5)

	// Use results to avoid unused errors
	fmt.Println(result1, result2, result3, result4, doubled, result5)
}
