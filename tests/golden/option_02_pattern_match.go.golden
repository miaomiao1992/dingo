package main

type OptionTag uint8

const (
	OptionTagSome OptionTag = iota
	OptionTagNone
)

type Option struct {
	tag  OptionTag
	some *string
}

func OptionSome(arg0 string) Option {
	return Option{tag: OptionTagSome, some: &arg0}
}
func OptionNone() Option {
	return Option{tag: OptionTagNone}
}
func (e Option) IsSome() bool {
	return e.tag == OptionTagSome
}
func (e Option) IsNone() bool {
	return e.tag == OptionTagNone
}
func (o Option) Map(fn func(string) string) Option {
	switch o.tag {
	case OptionTagSome:
		if o.some != nil {
			return OptionSome(fn(*o.some))
		}
	case OptionTagNone:
		return o
	}
	panic("invalid Option state")
}
func (o Option) AndThen(fn func(string) Option) Option {
	switch o.tag {
	case OptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case OptionTagNone:
		return o
	}
	panic("invalid Option state")
}
func findUser(id int) Option {
	if id > 0 {
		return OptionSome("User" + string(rune(id)))
	}
	return OptionNone()
}
func getUserOrDefault(id int) string {
	user := findUser(id)

	scrutinee := user
	switch scrutinee.tag {
	case OptionTagSome:
		name := *scrutinee.some

		return name
	case OptionTagNone:

		return "Anonymous"
	}
	panic("unreachable: match is exhaustive")

}
func main() {
	name1 := getUserOrDefault(42)
	println("User 1:", name1)

	name2 := getUserOrDefault(-1)
	println("User 2:", name2)
}
