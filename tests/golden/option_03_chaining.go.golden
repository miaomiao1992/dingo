package main

// Test: Option type with chaining (map, and_then)
// Feature: Option type with method chaining
// Complexity: advanced

// dingo:n:0
type OptionTag uint8

const (
	OptionTagSome OptionTag = iota
	OptionTagNone
)

type Option struct {
	tag  OptionTag
	some *int
}

func OptionSome(arg0 int) Option {
	return Option{tag: OptionTagSome, some: &arg0}
}
func OptionNone() Option {
	return Option{tag: OptionTagNone}
}
func (e Option) IsSome() bool {
	return e.tag == OptionTagSome
}
func (e Option) IsNone() bool {
	return e.tag == OptionTagNone
}
func (o Option) Map(fn func(int) int) Option {
	switch o.tag {
	case OptionTagSome:
		if o.some != nil {
			return OptionSome(fn(*o.some))
		}
	case OptionTagNone:
		return o
	}
	panic("invalid Option state")
}
func (o Option) AndThen(fn func(int) Option) Option {
	switch o.tag {
	case OptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case OptionTagNone:
		return o
	}
	panic("invalid Option state")
}
func (o Option) Unwrap() int {
	if o.tag != OptionTagSome {
		panic("called Unwrap on None")
	}
	return *o.some
}
func getValue(id int) Option {
	if id > 0 {
		return OptionSome(id)
	}
	return OptionNone()
}
func processValue(opt Option) Option {
	return opt.
		Map(func(x __TYPE_INFERENCE_NEEDED) { return x * 2 }).
		AndThen(func(x __TYPE_INFERENCE_NEEDED) {
			if x > 10 {
				return OptionSome(x)
			}
			return OptionNone()
		})
}
func main() {
	result := processValue(getValue(10))
	if result.IsSome() {
		println("Result:", *result.some)
	} else {
		println("None")
	}
}
