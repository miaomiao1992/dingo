package main

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strings"
)

// Sum type for user status - no boilerplate needed!
enum UserStatus {
	Active,
	Pending,
	Suspended
}

// Domain models
type User struct {
	ID       int
	Username string
	Email    string
	Status   UserStatus
	Profile  *UserProfile  // Optional profile (Phase 7 - safe navigation)
}

type UserProfile struct {
	Bio         *string
	Website     *string
	PhoneNumber *string
	Country     *string
}

type RegisterRequest struct {
	Username string
	Email    string
	Password string
	Profile  *ProfileInput  // Optional profile data
}

type ProfileInput struct {
	Bio     *string
	Website *string
	Phone   *string
	Country *string
}

// Validation functions return Result types - explicit success/failure
// These will be called with the ? operator for automatic error propagation

func validateEmail(email string) Result<string, error> {
	if !strings.Contains(email, "@") || !strings.Contains(email, ".") {
		return Err("invalid email format")
	}
	return Ok(email)
}

func validatePassword(password string) Result<string, error> {
	if len(password) < 8 {
		return Err("password must be at least 8 characters")
	}
	return Ok(password)
}

func validateUsername(username string) Result<string, error> {
	if len(username) < 3 {
		return Err("username must be at least 3 characters")
	}
	if len(username) > 20 {
		return Err("username too long")
	}
	return Ok(username)
}

// Database operations using Result types
func checkUserExists(db *sql.DB, email string) Result<bool, error> {
	let exists bool
	let err = db.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE email = ?)").Scan(&exists)
	if err != nil {
		return Err(err)
	}
	return Ok(exists)
}

func hashPassword(password string) Result<string, error> {
	// Simplified for example - real code would use bcrypt
	if password == "" {
		return Err("cannot hash empty password")
	}
	return Ok("hashed_" + password)
}

func saveUser(db *sql.DB, username string, email string, hashedPwd string, status UserStatus, profile *UserProfile) Result<int64, error> {
	// Safe navigation for optional profile fields with defaults
	let bio = profile?.Bio ?? ""
	let website = profile?.Website ?? ""
	let phone = profile?.PhoneNumber ?? ""
	let country = profile?.Country ?? "US"

	let result, err = db.Exec(
		"INSERT INTO users (username, email, password, status, bio, website, phone, country) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
		username, email, hashedPwd, status, bio, website, phone, country,
	)
	if err != nil {
		return Err(err)
	}
	let id, err1 = result.LastInsertId()
	if err1 != nil {
		return Err(err1)
	}
	return Ok(id)
}

// Main business logic - showcases error propagation and safe navigation
// Demonstrates manual error handling (? operator support coming in future phase)
// NEW (Phase 7): Safe navigation (?.) and null coalescing (??) for optional fields
func registerUser(db *sql.DB, req RegisterRequest) Result<User, error> {
	// All validations with manual error checks
	let emailResult = validateEmail(req.Email)
	if emailResult.IsErr() {
		return Err("email validation failed")
	}
	let email = emailResult.Unwrap()

	let passwordResult = validatePassword(req.Password)
	if passwordResult.IsErr() {
		return Err("password validation failed")
	}
	let password = passwordResult.Unwrap()

	let usernameResult = validateUsername(req.Username)
	if usernameResult.IsErr() {
		return Err("username validation failed")
	}
	let username = usernameResult.Unwrap()

	// Check if user exists - guard clause
	let existsResult = checkUserExists(db, email)
	if existsResult.IsErr() {
		return Err("failed to check user existence")
	}
	if existsResult.Unwrap() {
		return Err("user already exists")
	}

	// Build user profile from optional input (Phase 7 - safe navigation)
	let userProfile = buildUserProfile(req.Profile)

	// Hash password and save user
	let hashedPasswordResult = hashPassword(password)
	if hashedPasswordResult.IsErr() {
		return Err("password hashing failed")
	}
	let hashedPassword = hashedPasswordResult.Unwrap()

	let idResult = saveUser(db, username, email, hashedPassword, UserStatus_Pending, userProfile)
	if idResult.IsErr() {
		return Err("failed to save user")
	}
	let id = idResult.Unwrap()

	// Return created user with type-safe enum status
	return Ok(User{
		ID:       int(id),
		Username: username,
		Email:    email,
		Status:   UserStatus_Pending,
		Profile:  userProfile,
	})
}

// NEW (Phase 7): Build user profile with safe defaults using ?. and ??
func buildUserProfile(input *ProfileInput) *UserProfile {
	// Safe navigation with null coalescing - extract optional fields with defaults
	// These would be verbose null checks in plain Go!
	return &UserProfile{
		Bio:         input?.Bio,          // Pass through optional bio
		Website:     input?.Website,      // Pass through optional website
		PhoneNumber: input?.Phone,        // Map input field to domain field
		Country:     input?.Country,      // Pass through optional country
	}
}

// HTTP handler - clean and focused on business logic
func handleRegister(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		let req RegisterRequest
		let err = json.NewDecoder(r.Body).Decode(&req)
		if err != nil {
			http.Error(w, "invalid request body", http.StatusBadRequest)
			return
		}

		// Process registration
		let result = registerUser(db, req)
		if result.IsOk() {
			let user = result.Unwrap()
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(user)
		} else {
			let err1 = result.UnwrapErr()
			http.Error(w, err1.Error(), http.StatusBadRequest)
		}
	}
}

// NEW (Phase 7): Handler demonstrating safe navigation in response formatting
func handleGetUser(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Extract user ID from query params
		let userID = r.URL.Query().Get("id")
		if userID == "" {
			http.Error(w, "user ID required", http.StatusBadRequest)
			return
		}

		// Fetch user (may return nil)
		let user = getUserByID(db, userID)

		// Safe navigation with defaults for JSON response
		// Compare this compact syntax to manual nil checks!
		let response = map[string]interface{}{
			"id":       userID,
			"username": user?.Username ?? "unknown",
			"email":    user?.Email ?? "no-email@example.com",
			"status":   getUserStatusString(user?.Status),
			// Nested safe navigation for profile fields
			"bio":     user?.Profile?.Bio ?? "No bio provided",
			"website": user?.Profile?.Website ?? "",
			"phone":   user?.Profile?.PhoneNumber ?? "",
			"country": user?.Profile?.Country ?? "Unknown",
		}

		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(response)
	}
}

// Helper functions for new handler
func getUserByID(db *sql.DB, id string) *User {
	// Simplified - would query database in real implementation
	return nil
}

func getUserStatusString(status UserStatus) string {
	if status == UserStatus_Active {
		return "active"
	}
	if status == UserStatus_Pending {
		return "pending"
	}
	if status == UserStatus_Suspended {
		return "suspended"
	}
	return "unknown"
}
