package main

import (
	"strings"
)

type RequestTag uint8

const (
	RequestTagGet RequestTag = iota
	RequestTagPost
	RequestTagDelete
)

type Request struct {
	tag    RequestTag
	get    *string
	_0     *string
	_1     *string
	delete *string
}

func RequestGet(arg0 string) Request {
	return Request{tag: RequestTagGet, get: &arg0}
}
func RequestPost(arg0 string, arg1 string) Request {
	return Request{tag: RequestTagPost, _0: &arg0, _1: &arg1}
}
func RequestDelete(arg0 string) Request {
	return Request{tag: RequestTagDelete, delete: &arg0}
}
func (e Request) IsGet() bool {
	return e.tag == RequestTagGet
}
func (e Request) IsPost() bool {
	return e.tag == RequestTagPost
}
func (e Request) IsDelete() bool {
	return e.tag == RequestTagDelete
}

type StatusTag uint8

const (
	StatusTagActive StatusTag = iota
	StatusTagPaused
	StatusTagStopped
)

type Status struct {
	tag    StatusTag
	active *int
	paused *int
}
func StatusActive(arg0 int) Status {
	return Status{tag: StatusTagActive, active: &arg0}
}
func StatusPaused(arg0 int) Status {
	return Status{tag: StatusTagPaused, paused: &arg0}
}
func StatusStopped() Status {
	return Status{tag: StatusTagStopped}
}
func (e Status) IsActive() bool {
	return e.tag == StatusTagActive
}
func (e Status) IsPaused() bool {
	return e.tag == StatusTagPaused
}
func (e Status) IsStopped() bool {
	return e.tag == StatusTagStopped
}

// Mixed if/where keywords in same match
func routeRequest(req Request) string {
	var result interface{}

	scrutinee := req
	switch scrutinee.tag {
	case RequestTagGet:
		path := *scrutinee.get

		if strings.HasPrefix(path, "/api/") {
			result = "API endpoint"

		} else if len(path) > 0 {
			result = "static resource"
		}
	case RequestTagPost:
		path := *scrutinee._0
		body := *scrutinee._1

		if len(body) > 100 && strings.Contains(path, "upload") {
			result = "large upload"

		} else if len(body) > 0 {
			result = "post request"
		}
	case RequestTagDelete:
		path := *scrutinee.delete

		if isProtected(path) {
			result = "forbidden"

		} else {
			result = "delete request"
		}
	}
	panic("unreachable: match is exhaustive")
	return result

}

// Guards with logical operators
func classifyStatus(status Status) string {
	var result2 interface{}

	scrutinee2 := status
	switch scrutinee2.tag {
	case StatusTagActive:
		count := *scrutinee2.active

		if count > 1000 || count < 0 {
			result2 = "unusual"

		} else if count >= 100 && count <= 1000 {
			result2 = "normal"

		} else {
			result2 = "low activity"
		}
	case StatusTagPaused:
		duration := *scrutinee2.paused

		if duration > 3600 {
			result2 = "long pause"
		}
	}
	panic("unreachable: match is exhaustive")
	return result2

}
func isProtected(path string) bool {
	return strings.HasPrefix(path, "/admin/")
}
func main() {
	println(routeRequest(Request_Get("/api/users")))
	println(classifyStatus(Status_Active(500)))

}
