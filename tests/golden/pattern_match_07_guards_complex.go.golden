package main

import (
	"strings"
)

type RequestTag uint8

const (
	RequestTagGet RequestTag = iota
	RequestTagPost
	RequestTagDelete
)

type Request struct {
	tag      RequestTag
	get_0    *string
	post_0   *string
	post_1   *string
	delete_0 *string
}

func Request_Get(arg0 string) Request {
	return Request{tag: RequestTagGet, get_0: &arg0}
}
func Request_Post(arg0 string, arg1 string) Request {
	return Request{tag: RequestTagPost, post_0: &arg0, post_1: &arg1}
}
func Request_Delete(arg0 string) Request {
	return Request{tag: RequestTagDelete, delete_0: &arg0}
}
func (e Request) IsGet() bool {
	return e.tag == RequestTagGet
}
func (e Request) IsPost() bool {
	return e.tag == RequestTagPost
}
func (e Request) IsDelete() bool {
	return e.tag == RequestTagDelete
}

type StatusTag uint8

const (
	StatusTagActive StatusTag = iota
	StatusTagPaused
	StatusTagStopped
)

type Status struct {
	tag      StatusTag
	active_0 *int
	paused_0 *int
}
func Status_Active(arg0 int) Status {
	return Status{tag: StatusTagActive, active_0: &arg0}
}
func Status_Paused(arg0 int) Status {
	return Status{tag: StatusTagPaused, paused_0: &arg0}
}
func Status_Stopped() Status {
	return Status{tag: StatusTagStopped}
}
func (e Status) IsActive() bool {
	return e.tag == StatusTagActive
}
func (e Status) IsPaused() bool {
	return e.tag == StatusTagPaused
}
func (e Status) IsStopped() bool {
	return e.tag == StatusTagStopped
}

// Mixed if/where keywords in same match
func routeRequest(req Request) string {
	var result interface{}

	scrutinee := req
	switch scrutinee.tag {
	case RequestTagGet:
		path := *scrutinee.get

		if strings.HasPrefix(path, "/api/") {
			result = "API endpoint"

		} else if len(path) > 0 {
			result = "static resource"
		}
	case RequestTagPost:
		path, body := *scrutinee.post

		if len(body) > 100 && strings.Contains(path, "upload") {
			result = "large upload"

		} else if len(body) > 0 {
			result = "post request"
		}
	case RequestTagDelete:
		path := *scrutinee.delete

		if isProtected(path) {
			result = "forbidden"

		} else {
			result = "delete request"
		}
	default:

		result = "unknown"
	}
	panic("unreachable: match is exhaustive")
	return result

}

// Guards with logical operators
func classifyStatus(status Status) string {
	var result2 interface{}

	scrutinee2 := status
	switch scrutinee2.tag {
	case StatusTagActive:
		count := *scrutinee2.active

		if count > 1000 || count < 0 {
			result2 = "unusual"

		} else if count >= 100 && count <= 1000 {
			result2 = "normal"

		} else {
			result2 = "low activity"
		}
	case StatusTagPaused:
		duration := *scrutinee2.paused

		if duration > 3600 {
			result2 = "long pause"

		} else if true {
			result2 = "short pause"
		}
	case StatusTagStopped:

		result2 = "stopped"
	}
	panic("unreachable: match is exhaustive")
	return result2

}

// Guards on different pattern types
func processValue(val interface{}) string {
	var result3 interface{}

	scrutinee3 := val.(type)
	switch scrutinee3.tag {
	case intTag:

		if val.(int) > 0 {
			result3 = "positive integer"

		} else if val.(int) < 0 {
			result3 = "negative integer"

		} else {
			result3 = "zero"
		}
	case stringTag:

		if len(val.(string)) > 0 {
			result3 = "non-empty string"

		} else {
			result3 = "empty string"
		}
	default:

		result3 = "other type"
	}
	panic("unreachable: match is exhaustive")
	return result3

}
func isProtected(path string) bool {
	return strings.HasPrefix(path, "/admin/")
}
func main() {
	println(routeRequest(Request_Get("/api/users")))
	println(classifyStatus(Status_Active(500)))
	println(processValue(42))
}
