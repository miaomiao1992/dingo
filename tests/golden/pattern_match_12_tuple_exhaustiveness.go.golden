package main

import (
	"errors"
)

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag   ResultTag
	ok  *int
	err *error
}

func Result_Ok(arg0 int) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func Result_Err(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}

// 6-element tuple (max limit) - demonstrates exhaustiveness with wildcards
func validateSixSteps(s1, s2, s3, s4, s5, s6 Result) string {

	elem0, elem1, elem2, elem3, elem4, elem5 := s1, s2, s3, s4, s5, s6

	switch elem0.tag {
	case ResultTagErr:
		switch elem1.tag {
		default:
			switch elem2.tag {
			default:
				switch elem3.tag {
				default:
					switch elem4.tag {
					default:
						switch elem5.tag {
						default:

							e := *elem0.err
							return "Step 1 failed: " + e.Error()
						}
					}
				}
			}
		}
	case ResultTagOk:
		switch elem1.tag {
		case ResultTagOk:
			switch elem2.tag {
			case ResultTagOk:
				switch elem3.tag {
				case ResultTagOk:
					switch elem4.tag {
					case ResultTagOk:
						switch elem5.tag {
						case ResultTagOk:

							_ := *elem0.ok
							_ := *elem1.ok
							_ := *elem2.ok
							_ := *elem3.ok
							_ := *elem4.ok
							_ := *elem5.ok
							return "All 6 steps succeeded"
						}
					}
				}
			}
		}
	default:
		switch elem1.tag {
		case ResultTagErr:
			switch elem2.tag {
			default:
				switch elem3.tag {
				default:
					switch elem4.tag {
					default:
						switch elem5.tag {
						default:

							e := *elem1.err
							return "Step 2 failed: " + e.Error()
						}
					}
				}
			}
		default:
			switch elem2.tag {
			case ResultTagErr:
				switch elem3.tag {
				default:
					switch elem4.tag {
					default:
						switch elem5.tag {
						default:

							e := *elem2.err
							return "Step 3 failed: " + e.Error()
						}
					}
				}
			default:
				switch elem3.tag {
				case ResultTagErr:
					switch elem4.tag {
					default:
						switch elem5.tag {
						default:

							e := *elem3.err
							return "Step 4 failed: " + e.Error()
						}
					}
				default:
					switch elem4.tag {
					case ResultTagErr:
						switch elem5.tag {
						default:

							e := *elem4.err
							return "Step 5 failed: " + e.Error()
						}
					default:
						switch elem5.tag {
						case ResultTagErr:

							e := *elem5.err
							return "Step 6 failed: " + e.Error()
						}
					}
				}
			}
		}
	}
	panic("unreachable: match is exhaustive")

}

// Example of exhaustive 4-element tuple
func processFourResults(r1, r2, r3, r4 Result) string {

	elem0, elem1, elem2, elem3 := r1, r2, r3, r4

	switch elem0.tag {
	case ResultTagOk:
		switch elem1.tag {
		case ResultTagOk:
			switch elem2.tag {
			case ResultTagOk:
				switch elem3.tag {
				case ResultTagOk:

					a := *elem0.ok
					b := *elem1.ok
					c := *elem2.ok
					d := *elem3.ok
					return "All ok: " + string(a+b+c+d)
				}
			}
		}
	default:
		switch elem1.tag {
		default:
			switch elem2.tag {
			default:
				switch elem3.tag {
				default:

					return "At least one error occurred"
				}
			}
		}
	}
	panic("unreachable: match is exhaustive")

}
func main() {
	r1 := Result_Ok(1)
	r2 := Result_Ok(2)
	r3 := Result_Err(errors.New("step 3 error"))
	r4 := Result_Ok(4)
	r5 := Result_Ok(5)
	r6 := Result_Ok(6)

	result := validateSixSteps(r1, r2, r3, r4, r5, r6)
	println(result)

	result2 := processFourResults(r1, r2, r3, r4)
	println(result2)
}
