package main

import "errors"

// Test: Exhaustiveness checking with max 6-element tuple
// Feature: Tuple pattern destructuring - exhaustiveness
// Complexity: advanced

// dingo:n:0
type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag ResultTag
	err *error
	ok  *int
}

func ResultOk(arg0 int) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func ResultErr(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}
func (r Result) Map(fn func(int) int) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return ResultOk(fn(*r.ok))
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func (r Result) AndThen(fn func(int) Result) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return fn(*r.ok)
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}

// 6-element tuple (max limit) - demonstrates exhaustiveness with wildcards
func validateSixSteps(s1, s2, s3, s4, s5, s6 Result) string {
	// DINGO_MATCH_START: (s1, s2, s3, s4, s5, s6)
	elem0, elem1, elem2, elem3, elem4, elem5 := s1, s2, s3, s4, s5, s6
	// DINGO_TUPLE_PATTERN: (Ok, Ok, Ok, Ok, Ok, Ok) | (Err, _, _, _, _, _) | (_, Err, _, _, _, _) | (_, _, Err, _, _, _) | (_, _, _, Err, _, _) | (_, _, _, _, Err, _) | (_, _, _, _, _, Err) | ARITY: 6
	switch elem0.tag {
	case ResultTagErr:
		switch elem1.tag {
		default:
			switch elem2.tag {
			default:
				switch elem3.tag {
				default:
					switch elem4.tag {
					default:
						switch elem5.tag {
						default:
							// DINGO_TUPLE_ARM: (Err(e), _, _, _, _, _)
							e := *elem0.err
							return "Step 1 failed: " + e.Error()
						}
					}
				}
			}
		}
	case ResultTagOk:
		switch elem1.tag {
		case ResultTagOk:
			switch elem2.tag {
			case ResultTagOk:
				switch elem3.tag {
				case ResultTagOk:
					switch elem4.tag {
					case ResultTagOk:
						switch elem5.tag {
						case ResultTagOk:
							// DINGO_TUPLE_ARM: (Ok(_), Ok(_), Ok(_), Ok(_), Ok(_), Ok(_))
							_ := *elem0.ok
							_ := *elem1.ok
							_ := *elem2.ok
							_ := *elem3.ok
							_ := *elem4.ok
							_ := *elem5.ok
							return "All 6 steps succeeded"
						}
					}
				}
			}
		}
	default:
		switch elem1.tag {
		case ResultTagErr:
			switch elem2.tag {
			default:
				switch elem3.tag {
				default:
					switch elem4.tag {
					default:
						switch elem5.tag {
						default:
							// DINGO_TUPLE_ARM: (_, Err(e), _, _, _, _)
							e := *elem1.err
							return "Step 2 failed: " + e.Error()
						}
					}
				}
			}
		default:
			switch elem2.tag {
			case ResultTagErr:
				switch elem3.tag {
				default:
					switch elem4.tag {
					default:
						switch elem5.tag {
						default:
							// DINGO_TUPLE_ARM: (_, _, Err(e), _, _, _)
							e := *elem2.err
							return "Step 3 failed: " + e.Error()
						}
					}
				}
			default:
				switch elem3.tag {
				case ResultTagErr:
					switch elem4.tag {
					default:
						switch elem5.tag {
						default:
							// DINGO_TUPLE_ARM: (_, _, _, Err(e), _, _)
							e := *elem3.err
							return "Step 4 failed: " + e.Error()
						}
					}
				default:
					switch elem4.tag {
					case ResultTagErr:
						switch elem5.tag {
						default:
							// DINGO_TUPLE_ARM: (_, _, _, _, Err(e), _)
							e := *elem4.err
							return "Step 5 failed: " + e.Error()
						}
					default:
						switch elem5.tag {
						case ResultTagErr:
							// DINGO_TUPLE_ARM: (_, _, _, _, _, Err(e))
							e := *elem5.err
							return "Step 6 failed: " + e.Error()
						}
					}
				}
			}
		}
	}
	panic("unreachable: match is exhaustive")
	// DINGO_MATCH_END

}

// Example of exhaustive 4-element tuple
func processFourResults(r1, r2, r3, r4 Result) string {
	// DINGO_MATCH_START: (r1, r2, r3, r4)
	elem0, elem1, elem2, elem3 := r1, r2, r3, r4
	// DINGO_TUPLE_PATTERN: (Ok, Ok, Ok, Ok) | (_, _, _, _) | ARITY: 4
	switch elem0.tag {
	case ResultTagOk:
		switch elem1.tag {
		case ResultTagOk:
			switch elem2.tag {
			case ResultTagOk:
				switch elem3.tag {
				case ResultTagOk:
					// DINGO_TUPLE_ARM: (Ok(a), Ok(b), Ok(c), Ok(d))
					a := *elem0.ok
					b := *elem1.ok
					c := *elem2.ok
					d := *elem3.ok
					return "All ok: " + string(a+b+c+d)
				}
			}
		}
	default:
		switch elem1.tag {
		default:
			switch elem2.tag {
			default:
				switch elem3.tag {
				default:
					// DINGO_TUPLE_ARM: (_, _, _, _)
					return "At least one error occurred"
				}
			}
		}
	}
	panic("unreachable: match is exhaustive")
	// DINGO_MATCH_END

}
func main() {
	r1 := ResultOk(1)
	r2 := ResultOk(2)
	r3 := ResultErr(errors.New("step 3 error"))
	r4 := ResultOk(4)
	r5 := ResultOk(5)
	r6 := ResultOk(6)

	result := validateSixSteps(r1, r2, r3, r4, r5, r6)
	println(result)

	result2 := processFourResults(r1, r2, r3, r4)
	println(result2)
}

// Non-exhaustive example (would fail - commented out):
// func nonExhaustive(r1, r2 Result) string {
//     return match (r1, r2) {
//         (Ok(x), Ok(y)) => "both ok",
//         (Ok(x), Err(e)) => "second error"
//         // Missing: (Err, Ok) and (Err, Err)
//     }
// }
