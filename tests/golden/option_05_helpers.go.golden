package main

// Test: Option[T] helper methods
// Feature: UnwrapOrElse, Map, AndThen, Filter
// Complexity: advanced

import "fmt"

// Configuration struct
type Config struct {
	Port    int
	Verbose bool
}

// getPort returns an optional port value
func getPort() Option_int {
	// Simulate reading from environment - might fail
	return Option_int_Some(8080)
}

// getVerboseFlag returns an optional verbose flag
func getVerboseFlag() Option_bool {
	return Option_bool_None()
}

// parseConfig builds a Config from optional values
func parseConfig() Config {
	// UnwrapOrElse: Use default value from function if None
	port := getPort().UnwrapOrElse(func() int {
		return 3000
	})

	// UnwrapOr: Use default value directly
	verbose := getVerboseFlag().UnwrapOr(false)

	return Config{Port: port, Verbose: verbose}
}

// processPort demonstrates Map transformation
func processPort(opt Option_int) Option_int {
	// Map: Transform Some value, propagate None
	return opt.Map(func(port int) interface{} {
		return port * 2
	})
}

// validatePort demonstrates Filter
func validatePort(opt Option_int) Option_int {
	// Filter: Keep Some values that pass predicate
	return opt.Filter(func(port int) bool {
		return port > 1024 && port < 65535
	})
}

// getValidPort demonstrates AndThen chaining
func getValidPort(id int) Option_int {
	return getPort().AndThen(func(port int) Option_int {
		// Chain operation: validate and adjust
		if port < 1024 {
			return Option_int_None()
		}
		return Option_int_Some(port + id)
	})
}

// Complex chaining example
func processConfig(useDefault bool) Option_int {
	port := getPort()

	// Chain multiple operations
	result := port.
		Map(func(p int) interface{} { return p + 1000 }).
		Filter(func(p int) bool { return p < 10000 }).
		AndThen(func(p int) Option_int {
			if p%2 == 0 {
				return Option_int_Some(p / 2)
			}
			return Option_int_None()
		})

	if result.IsNone() && useDefault {
		return Option_int_Some(3000)
	}

	return result
}
func main() {
	// Test UnwrapOrElse
	cfg := parseConfig()
	fmt.Printf("Config: Port=%d, Verbose=%v\n", cfg.Port, cfg.Verbose)

	// Test Map
	doubled := processPort(getPort())
	if doubled.IsSome() {
		fmt.Printf("Doubled port: %d\n", *doubled.some)
	}

	// Test Filter
	validated := validatePort(Option_int_Some(8080))
	if validated.IsSome() {
		fmt.Printf("Valid port: %d\n", *validated.some)
	}

	invalidPort := validatePort(Option_int_Some(100))
	if invalidPort.IsNone() {
		fmt.Println("Invalid port filtered out")
	}

	// Test AndThen
	adjustedPort := getValidPort(10)
	if adjustedPort.IsSome() {
		fmt.Printf("Adjusted port: %d\n", *adjustedPort.some)
	}

	// Test complex chaining
	final := processConfig(true)
	if final.IsSome() {
		fmt.Printf("Final port: %d\n", *final.some)
	} else {
		fmt.Println("No final port")
	}
}
