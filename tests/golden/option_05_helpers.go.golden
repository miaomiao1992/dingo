package main

import "fmt"

type Config struct {
	Port    int
	Verbose bool
}

func getPort() Option_int {

	return Option_int_Some(8080)
}
func getVerboseFlag() Option_bool {
	return Option_bool_None()
}
func parseConfig() Config {

	port := getPort().UnwrapOrElse(func() int {
		return 3000
	})

	verbose := getVerboseFlag().UnwrapOr(false)

	return Config{Port: port, Verbose: verbose}
}
func processPort(opt Option_int) Option_int {

	return opt.Map(func(port int) interface{} {
		return port * 2
	})
}
func validatePort(opt Option_int) Option_int {

	return opt.Filter(func(port int) bool {
		return port > 1024 && port < 65535
	})
}
func getValidPort(id int) Option_int {
	return getPort().AndThen(func(port int) Option_int {

		if port < 1024 {
			return Option_int_None()
		}
		return Option_int_Some(port + id)
	})
}
func processConfig(useDefault bool) Option_int {
	port := getPort()

	result := port.
		Map(func(p int) interface{} { return p + 1000 }).
		Filter(func(p int) bool { return p < 10000 }).
		AndThen(func(p int) Option_int {
			if p%2 == 0 {
				return Option_int_Some(p / 2)
			}
			return Option_int_None()
		})

	if result.IsNone() && useDefault {
		return Option_int_Some(3000)
	}

	return result
}
func main() {

	cfg := parseConfig()
	fmt.Printf("Config: Port=%d, Verbose=%v\n", cfg.Port, cfg.Verbose)

	doubled := processPort(getPort())
	if doubled.IsSome() {
		fmt.Printf("Doubled port: %d\n", *doubled.some_0)
	}

	validated := validatePort(Option_int_Some(8080))
	if validated.IsSome() {
		fmt.Printf("Valid port: %d\n", *validated.some_0)
	}

	invalidPort := validatePort(Option_int_Some(100))
	if invalidPort.IsNone() {
		fmt.Println("Invalid port filtered out")
	}

	adjustedPort := getValidPort(10)
	if adjustedPort.IsSome() {
		fmt.Printf("Adjusted port: %d\n", *adjustedPort.some_0)
	}

	final := processConfig(true)
	if final.IsSome() {
		fmt.Printf("Final port: %d\n", *final.some_0)
	} else {
		fmt.Println("No final port")
	}
}
