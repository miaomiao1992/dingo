package main

import "errors"

// Test: Result type with method chaining
// Feature: Result type with map and and_then
// Complexity: advanced

// dingo:n:0
type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag ResultTag
	err *error
	ok  *int
}

func ResultOk(arg0 int) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func ResultErr(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}
func (r Result) Map(fn func(int) int) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return ResultOk(fn(*r.ok))
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func (r Result) AndThen(fn func(int) Result) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return fn(*r.ok)
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func parse(s string) Result {
	if s == "" {
		return ResultErr(errors.New("empty string"))
	}
	return ResultOk(len(s))
}
func validate(n int) Result {
	if n < 5 {
		return ResultErr(errors.New("too short"))
	}
	return ResultOk(n)
}
func processInput(input string) Result {
	return parse(input).
		AndThen(func(x __TYPE_INFERENCE_NEEDED) { return validate(x) }).
		Map(func(x __TYPE_INFERENCE_NEEDED) { return x * 2 })
}
func main() {
	result := processInput("hello world")
	if result.IsOk() {
		println("Result:", *result.ok)
	}
}
