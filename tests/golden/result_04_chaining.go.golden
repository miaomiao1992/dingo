package main

import "errors"

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag   ResultTag
	ok  *int
	err *error
}

func Result_Ok(arg0 int) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func Result_Err(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}

// Map method for Result chaining
func (r Result) Map(f func(int) int) Result {
	if r.IsOk() {
		return Result_Ok(f(*r.ok))
	}
	return r
}

// AndThen method for Result chaining
func (r Result) AndThen(f func(int) Result) Result {
	if r.IsOk() {
		return f(*r.ok)
	}
	return r
}

func parse(s string) Result {
	if s == "" {
		return Result_Err(errors.New("empty string"))
	}
	return Result_Ok(len(s))
}
func validate(n int) Result {
	if n < 5 {
		return Result_Err(errors.New("too short"))
	}
	return Result_Ok(n)
}
func processInput(input string) Result {
	return parse(input).AndThen(func(x int) Result {
		return validate(x)
	}).Map(func(x int) int {
		return x * 2
	})
}
func main() {
	result := processInput("hello world")
	if result.IsOk() {
		println("Result:", *result.ok)
	}
}
