package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
)

type UserRoleTag uint8

const (
	UserRoleTagGuest UserRoleTag = iota
	UserRoleTagUser
	UserRoleTagAdmin
	UserRoleTagModerator
)

type UserRole struct {
	tag UserRoleTag
}

func UserRoleGuest() UserRole {
	return UserRole{tag: UserRoleTagGuest}
}
func UserRoleUser() UserRole {
	return UserRole{tag: UserRoleTagUser}
}
func UserRoleAdmin() UserRole {
	return UserRole{tag: UserRoleTagAdmin}
}
func UserRoleModerator() UserRole {
	return UserRole{tag: UserRoleTagModerator}
}
func (e UserRole) IsGuest() bool {
	return e.tag == UserRoleTagGuest
}
func (e UserRole) IsUser() bool {
	return e.tag == UserRoleTagUser
}
func (e UserRole) IsAdmin() bool {
	return e.tag == UserRoleTagAdmin
}
func (e UserRole) IsModerator() bool {
	return e.tag == UserRoleTagModerator
}

type User struct {
	ID       string
	Email    string
	Name     string
	Role     UserRole
	Verified bool
	Bio      *string
}
type Action struct {
	Type       string
	Permission string
}
type Response struct {
	StatusCode int
	Body       map[string]interface{}
}
type JWTClaims struct {
	UserID string
	Exp    int64
}
func authenticateUser(token string) (User, error) {
	if token == "" {
		return User{}, fmt.Errorf("missing token")
	}

	tmp, err := parseJWT(token)

	if err != nil {
		return User{}, err
	}
	// dingo:e:1
	var claims = tmp
	tmp1, err1 := fetchUserFromDB(claims.UserID)

	if err1 != nil {
		return User{}, err1
	}
	// dingo:e:1
	var user = tmp1

	return user, nil
}
func parseJWT(token string) (JWTClaims, error) {
	if !strings.HasPrefix(token, "Bearer ") {
		return JWTClaims{}, fmt.Errorf("invalid format")
	}

	return JWTClaims{UserID: "user_123", Exp: 3600}, nil
}
func fetchUserFromDB(id string) (User, error) {
	if id == "" {
		return User{}, fmt.Errorf("not found")
	}

	bio := "Software developer"

	return User{
		ID:       id,
		Email:    "user@example.com",
		Name:     "John Doe",
		Role:     UserRole_User(),
		Verified: true,
		Bio:      &bio,
	}, nil
}
func handleRequest(user User, action Action) (Response, error) {

	scrutinee := user.Role
	switch scrutinee.tag {
	case UserRoleTagAdmin:

		{
			return executeAdminAction(user.ID, action)
		}
	case UserRoleTagModerator:

		{
			return executeModAction(user.ID, action)
		}
	case UserRoleTagUser:

		{
			if !user.Verified {
				return Response{}, fmt.Errorf("verification required")
			}
			return executeUserAction(user.ID, action)
		}
	case UserRoleTagGuest:

		{
			return executeGuestAction(action)
		}
	}
	panic("unreachable: match is exhaustive")

}
func getUserRoleString(role UserRole) string {

	scrutinee2 := role
	switch scrutinee2.tag {
	case UserRoleTagAdmin:

		return "admin"
	case UserRoleTagModerator:

		return "moderator"
	case UserRoleTagUser:

		return "user"
	case UserRoleTagGuest:

		return "guest"
	}
	panic("unreachable: match is exhaustive")

}
func getUserBio(user User) string {
	return func() string {
		coalesce := user.Bio
		if coalesce.IsSome() {
			return coalesce.Unwrap()
		}
		return "No bio provided"
	}()
}
func createUserPipeline(email string, password string) (User, error) {
	tmp, err := validateEmail(email)

	if err != nil {
		return User{}, err
	}
	// dingo:e:1
	var validated = tmp
	tmp1, err1 := hashPassword(password)

	if err1 != nil {
		return User{}, err1
	}
	// dingo:e:1
	var hashed = tmp1
	tmp2, err2 := createUserInDB(validated, hashed)

	if err2 != nil {
		return User{}, err2
	}
	// dingo:e:1
	var user = tmp2

	return user, nil
}
func validateEmail(email string) (string, error) {
	if !strings.Contains(email, "@") {
		return "", fmt.Errorf("invalid email")
	}
	return email, nil
}
func hashPassword(password string) (string, error) {
	if len(password) < 8 {
		return "", fmt.Errorf("password too short")
	}
	return "hashed_" + password, nil
}
func createUserInDB(email string, hashedPassword string) (User, error) {
	return User{
		ID:       "new_user_123",
		Email:    email,
		Name:     strings.Split(email, "@")[0],
		Role:     UserRole_Guest(),
		Verified: false,
		Bio:      nil,
	}, nil
}
func handleApiRequest(req *http.Request) (Response, error) {
	authHeader := req.Header.Get("Authorization")
	if authHeader == "" {
		return Response{}, fmt.Errorf("missing Authorization header")
	}

	tmp, err := authenticateUser(authHeader)

	if err != nil {
		return Response{}, err
	}
	// dingo:e:1
	var user = tmp
	tmp1, err1 := parseActionFromRequest(req)

	if err1 != nil {
		return Response{}, err1
	}
	// dingo:e:1
	var action = tmp1

	tmp2, err2 := handleRequest(user, action)

	if err2 != nil {
		return Response{}, err2
	}
	// dingo:e:1
	var response = tmp2

	response.Body["user_bio"] = getUserBio(user)
	response.Body["user_role"] = getUserRoleString(user.Role)

	return response, nil
}
func parseActionFromRequest(req *http.Request) (Action, error) {
	var action Action
	if err := json.NewDecoder(req.Body).Decode(&action); err != nil {
		return Action{}, fmt.Errorf("invalid body")
	}
	return action, nil
}
func executeAdminAction(id string, action Action) (Response, error) {
	return Response{
		StatusCode: 200,
		Body: map[string]interface{}{
			"status": "admin action",
			"user":   id,
		},
	}, nil
}
func executeModAction(id string, action Action) (Response, error) {
	return Response{
		StatusCode: 200,
		Body: map[string]interface{}{
			"status": "moderator action",
		},
	}, nil
}
func executeUserAction(id string, action Action) (Response, error) {
	return Response{
		StatusCode: 200,
		Body: map[string]interface{}{
			"status": "user action",
		},
	}, nil
}
func executeGuestAction(action Action) (Response, error) {
	return Response{
		StatusCode: 200,
		Body: map[string]interface{}{
			"status": "guest action",
		},
	}, nil
}
func main() {
	http.HandleFunc("/api", func(w http.ResponseWriter, r *http.Request) {
		response, err := handleApiRequest(r)

		if err != nil {
			w.WriteHeader(500)
			json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
			return
		}

		w.WriteHeader(response.StatusCode)
		json.NewEncoder(w).Encode(response.Body)
	})

	fmt.Println("Dingo Showcase Server - Demonstrating:")
	fmt.Println("  - Sum types (enums)")
	fmt.Println("  - Error propagation (? operator)")
	fmt.Println("  - Pattern matching (exhaustiveness)")
	fmt.Println("  - Null coalescing (?? operator)")
	fmt.Println("Starting on :8080...")

	http.ListenAndServe(":8080", nil)
}
