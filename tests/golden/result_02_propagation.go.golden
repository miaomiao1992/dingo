package main

import (
	"errors"
)

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag ResultTag
	err *error
	ok  *string
}

func ResultOk(arg0 string) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func ResultErr(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}
func (r Result) Map(fn func(string) string) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return ResultOk(fn(*r.ok))
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func (r Result) AndThen(fn func(string) Result) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return fn(*r.ok)
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func fetchUser(id int) Result {
	if id <= 0 {
		return ResultErr(errors.New("invalid user ID"))
	}
	return ResultOk("User" + string(rune(id)))
}
func validateUser(name string) Result {
	if name == "" {
		return ResultErr(errors.New("empty user name"))
	}
	return ResultOk(name)
}
func processUser(id int) Result {
	user := fetchUser(id)

	scrutinee := user
	switch scrutinee.tag {
	case ResultTagOk:
		u := *scrutinee.ok

		{
			validated := validateUser(u)

			scrutinee3 := validated
			switch scrutinee3.tag {
			case ResultTagOk:
				v := *scrutinee3.ok

				return ResultOk(v)
			case ResultTagErr:
				e := *scrutinee3.err

				return ResultErr(e)
			}
			panic("unreachable: match is exhaustive")

		}
	case ResultTagErr:
		e := *scrutinee.err

		return ResultErr(e)
	}
	panic("unreachable: match is exhaustive")

}
func main() {
	result := processUser(42)

	scrutinee2 := result
	switch scrutinee2.tag {
	case ResultTagOk:
		user := *scrutinee2.ok

		return println("Success:", user)
	case ResultTagErr:
		error := *scrutinee2.err

		return println("Error:", error)
	}
	panic("unreachable: match is exhaustive")

}
