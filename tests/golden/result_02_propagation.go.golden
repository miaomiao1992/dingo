package main

import (
	"errors"
)

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag ResultTag
	ok  *string
	err *error
}

func ResultOk(arg0 string) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func ResultErr(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}
func fetchUser(id int) Result {
	if id <= 0 {
		return ResultErr(errors.New("invalid user ID"))
	}
	return ResultOk("User" + string(rune(id)))
}
func validateUser(name string) Result {
	if name == "" {
		return ResultErr(errors.New("empty user name"))
	}
	return ResultOk(name)
}
func processUser(id int) Result {
	user := fetchUser(id)

	scrutinee := user
	switch scrutinee.tag {
	case ResultTagOk:
		u := *scrutinee.ok

		{
			validated := validateUser(u)

			scrutinee := validated
			switch scrutinee.tag {
			case ResultTagOk:
				v := *scrutinee.ok

				return ResultOk(v)
			case ResultTagErr:
				e := scrutinee.err

				return ResultErr(e)
			}
			panic("unreachable: match is exhaustive")

		}
	case ResultTagErr:
		e := scrutinee.err

		return ResultErr(e)
	}
	panic("unreachable: match is exhaustive")

}
func main() {
	result := processUser(42)

	scrutinee2 := result
	switch scrutinee2.tag {
	case ResultTagOk:
		user := *scrutinee2.ok

		println("Success:", user)
	case ResultTagErr:
		error := scrutinee2.err

		println("Error:", error)
	}
	panic("unreachable: match is exhaustive")

}
