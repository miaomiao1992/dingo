# Dingo Language TextMate Grammar (YAML)
# Compile to JSON with: js-yaml dingo.tmLanguage.yaml > dingo.tmLanguage.json

name: Dingo
scopeName: source.dingo
fileTypes:
  - dingo

patterns:
  - include: '#comments'
  - include: '#keywords'
  - include: '#result-type'
  - include: '#option-type'
  - include: '#enum-variants'
  - include: '#types'
  - include: '#functions'
  - include: '#lambdas'
  - include: '#operators'
  - include: '#strings'
  - include: '#numbers'
  - include: '#constants'
  - include: '#attributes'

repository:
  # ===== COMMENTS =====
  comments:
    patterns:
      - name: comment.line.double-slash.dingo
        begin: //
        end: $
        patterns:
          - name: meta.toc-list.banner.dingo
            match: \b(TODO|FIXME|XXX|HACK|NOTE)\b:?

      - name: comment.block.dingo
        begin: /\*
        end: \*/
        patterns:
          - name: meta.toc-list.banner.dingo
            match: \b(TODO|FIXME|XXX|HACK|NOTE)\b:?

  # ===== KEYWORDS =====
  keywords:
    patterns:
      - name: keyword.control.dingo
        match: \b(if|else|for|while|loop|break|continue|return|defer|go|select|case|default)\b

      - name: keyword.control.match.dingo
        match: \b(match)\b
        comment: Pattern matching keyword

      - name: keyword.declaration.dingo
        match: \b(func|let|const|var|type|struct|interface|enum|impl|trait)\b

      - name: keyword.other.dingo
        match: \b(package|import|as|pub|mut)\b

      - name: storage.modifier.dingo
        match: \b(mut|pub)\b

  # ===== RESULT TYPE =====
  result-type:
    patterns:
      - name: entity.name.type.result.dingo
        match: \bResult\s*<
        captures:
          0: { name: support.type.result.dingo }
        comment: Result<T, E> type annotation

      - name: support.function.result.dingo
        match: \b(Ok|Err)\s*(?=\()
        comment: Result constructors

  # ===== OPTION TYPE =====
  option-type:
    patterns:
      - name: entity.name.type.option.dingo
        match: \bOption\s*<
        captures:
          0: { name: support.type.option.dingo }
        comment: Option<T> type annotation

      - name: support.function.option.dingo
        match: \b(Some|None)\b
        comment: Option constructors

  # ===== ENUM VARIANTS =====
  enum-variants:
    patterns:
      - name: constant.language.enum-variant.dingo
        match: \b[A-Z][a-zA-Z0-9_]*\b(?=\s*(?:\(|\{|,|=>|\}))
        comment: Enum variant in pattern matching

  # ===== TYPES =====
  types:
    patterns:
      - name: storage.type.numeric.dingo
        match: \b(int|int8|int16|int32|int64|uint|uint8|uint16|uint32|uint64|uintptr)\b

      - name: storage.type.numeric.dingo
        match: \b(float32|float64|complex64|complex128)\b

      - name: storage.type.string.dingo
        match: \b(string|rune|byte)\b

      - name: storage.type.boolean.dingo
        match: \b(bool)\b

      - name: storage.type.dingo
        match: \b(error|any)\b

      - name: entity.name.type.dingo
        match: \b[A-Z][a-zA-Z0-9_]*\b
        comment: User-defined types (PascalCase)

  # ===== FUNCTIONS =====
  functions:
    patterns:
      - name: meta.function.declaration.dingo
        begin: \b(func)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:<[^>]*>)?\s*\(
        beginCaptures:
          1: { name: keyword.declaration.function.dingo }
          2: { name: entity.name.function.dingo }
        end: \)
        patterns:
          - include: '#parameters'
          - include: '#types'

      - name: entity.name.function.call.dingo
        match: \b([a-z_][a-zA-Z0-9_]*)\s*(?=\()
        comment: Function call

      - name: entity.name.function.method.dingo
        match: \.([a-z_][a-zA-Z0-9_]*)\s*(?=\()
        comment: Method call

  # ===== LAMBDAS =====
  lambdas:
    patterns:
      - name: meta.function.lambda.dingo
        begin: \|
        beginCaptures:
          0: { name: punctuation.definition.parameters.begin.lambda.dingo }
        end: \|
        endCaptures:
          0: { name: punctuation.definition.parameters.end.lambda.dingo }
        patterns:
          - include: '#parameters'
        comment: Rust-style lambda parameters |a, b|

  # ===== PARAMETERS =====
  parameters:
    patterns:
      - name: variable.parameter.dingo
        match: \b[a-z_][a-zA-Z0-9_]*\b

  # ===== OPERATORS =====
  operators:
    patterns:
      - name: keyword.operator.error-propagation.dingo
        match: \?
        comment: Error propagation operator - unwrap Result/Option or return early

      - name: keyword.operator.null-coalescing.dingo
        match: \?\?
        comment: Null coalescing operator

      - name: keyword.operator.arrow.dingo
        match: =>
        comment: Match arm arrow and lambda arrow

      - name: keyword.operator.assignment.dingo
        match: (:=|=|\+=|-=|\*=|/=|%=|&=|\|=|\^=|<<=|>>=|&\^=)

      - name: keyword.operator.comparison.dingo
        match: (==|!=|<|>|<=|>=)

      - name: keyword.operator.logical.dingo
        match: (&&|\|\||!)

      - name: keyword.operator.arithmetic.dingo
        match: (\+|-|\*|/|%)

      - name: keyword.operator.bitwise.dingo
        match: (&|\||\^|<<|>>|&\^)

      - name: keyword.operator.channel.dingo
        match: (<-)

      - name: keyword.operator.type-annotation.dingo
        match: ":"

      - name: keyword.operator.return-type.dingo
        match: ->

  # ===== STRINGS =====
  strings:
    patterns:
      - name: string.quoted.double.dingo
        begin: "\""
        end: "\""
        patterns:
          - name: constant.character.escape.dingo
            match: \\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}|[abfnrtv\\'\"])

          - name: meta.string.interpolation.dingo
            begin: \$\{
            end: \}
            patterns:
              - include: $self

          - name: invalid.illegal.unknown-escape.dingo
            match: \\.

      - name: string.quoted.single.dingo
        begin: "'"
        end: "'"
        patterns:
          - name: constant.character.escape.dingo
            match: \\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}|[abfnrtv\\'\"])

      - name: string.quoted.raw.dingo
        begin: "`"
        end: "`"
        comment: Raw string literal (no escaping)

  # ===== NUMBERS =====
  numbers:
    patterns:
      - name: constant.numeric.hex.dingo
        match: \b0[xX][0-9a-fA-F_]+\b

      - name: constant.numeric.octal.dingo
        match: \b0[oO][0-7_]+\b

      - name: constant.numeric.binary.dingo
        match: \b0[bB][01_]+\b

      - name: constant.numeric.float.dingo
        match: \b[0-9][0-9_]*\.[0-9_]+([eE][+-]?[0-9_]+)?\b

      - name: constant.numeric.integer.dingo
        match: \b[0-9][0-9_]*\b

  # ===== CONSTANTS =====
  constants:
    patterns:
      - name: constant.language.dingo
        match: \b(true|false|nil)\b

      - name: constant.language.iota.dingo
        match: \b(iota)\b

  # ===== ATTRIBUTES =====
  attributes:
    patterns:
      - name: meta.attribute.dingo
        begin: "#\\["
        end: "\\]"
        patterns:
          - name: entity.name.function.attribute.dingo
            match: "[a-zA-Z_][a-zA-Z0-9_]*"
        comment: Attribute syntax like #[derive(Debug)]
